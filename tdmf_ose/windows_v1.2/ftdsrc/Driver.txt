Replication 5.0.1

Review of differences between the UNIX and NT 4.0 device driver

The NT driver used common code with the UNIX base until 1999/08/25 at which time it was split off.  Although there was some effort that common bugs fixs were applied to both there is no gurentee.

That said, much of the code and I/O flow is the same.

Other than the obvious way the IRPs are different that buff structs, the difference you should know about is in the way I/Os are commpleted.
As of UNIX 4.4, if an I/O would modify the pstore this I/O is completed asyncroniously with respects to the pstore I/O (bug).  In NT the user I/O is not completed until the pstore has been updated.
This is the main reason for using the kernel threads in this driver.

If a device's I/O would modify the lrdb on the pstore device the do_write dispatch routine puts the I/O on the pstore queue and sets the pstore Semaphore.  Sometime later the pstore thread wakes up, again determines if the I/O would modify the lrdb, if so creates the pstore write, and waits for it to complete.  At which time the I/O is sent on down to the device below us.

On completion of any journaling I/O the IRP is put on the commit queue and the commit Semaphore is set.  The commit thread wakes up, updates some statistics, if we are in syncmode, put the IRP on the syncmode queue, else just complete the I/O.

Every one second the Sync thread wakes up determines if an I/O has been sitting around longer than lgp->sync_timeout, if so the I/O is completed.

files reviewed:
ftd_def.h
ftdio.h
ftd_nt.c
ftd_bab.c

ftd_def.h - Internal data structures

Two types of locks are used, a mutex (used in kernel threads and dispatch routines), and a spinlocks usually for list manipulation.
This was found to improve performance, for NT they are defined as:

#define	FTD_CONTEXT		ERESOURCE_THREAD
#define	FTD_IRQL		KIRQL

For UNIX the same locking mechanism is used everywhere, which one depends on the platform.

Device extensions(ftd_dev and ftd_lg) and a global structure(ftd_ctl) each start with a signature, defined as:

typedef struct ftd_node_id {
	unsigned int	NodeType;			// a 32 bit identifier for the structure
	unsigned int	NodeSize;			// computed as sizeof(structure)
} ftd_node_id_t;

where nodetype as defined as:

#define	FTD_NODE_TYPE_CTL_DATA		    (0xfdecba10)
#define	FTD_NODE_TYPE_LG_DEVICE			(0xfdecba11)
#define	FTD_NODE_TYPE_ATTACHED_DEVICE	(0xfdecba12)
#define	FTD_NODE_TYPE_EXT_DEVICE		(0xfdecba13)

This makes finding all ftd structures in a crash dump possible.

Any specific NT data types necessary are appended to the end of the existing UNIX structures.

ftdio.h - Common structures and ioctls used both by user and kernel code.

Any errors returned from an ioctl that are not NTSTATUS are returned or'ed with:

FTD_DRIVER_ERROR_CODE

Again, any specific NT data types necessary are appended to the end of the existing UNIX structres.

ftd_nt.c - NT specific code, where the rubber hits the road.

functions:

ExceptionFilter(...) - common try/except handler
FindQueuedRequest(...) - common canceled IRP in a list searcher
SyncCancelRequest(...) - for IRPs that are in the sync queue, it recieves notification of a IRP that has been canceled by the system.
ftd_sync_thread(...) - every one second wakes up and walks the sync queue for IRPs that have timed out (lgp->sync_timeout), it completes them without an error, but writes a timeout error in the System Log.
ftd_commit_thread(...) - wakes up (on a Semaphore) when an IRP has been completed below us, updates statistics, and if in syncmode puts it on the sysnc queue.
ftd_write_pstore(...) - Creates an IRP to do a block write to the pstore device.
ftd_chk_pstore_list(...) - Checks to see if the lrdb bits have already been set by a previous IRP and completes the IRPs waiting on it.
ftd_pstore_thread(...) - wakes up (on a Semaphore) when an IRP that may update the pstore device is added to the queue.
DriverEntry(...) - creates memory, device and it's user symbolic name, checks the registry.
ftd_unload(...) - Unload routine, only works (sometimes) if the DBG define is set.
ftd_shutdown_flush(...) - does little.
ftd_create_dir(...) - Utility for creating symbolic links.
ftd_del_dir(...) - Utility for removing symbolic links.
ftd_init_ptrs(...) - Utility to initialize the IRP major function pointer array.
ftd_get_registry(...) - Get driver specific data.
ftd_ctl_get_device_nums(...) - device extensions are stored in an array (ftd_dev_state), this function returns the array index of a specific device as the UNIX major numbers.
finish_biodone(...) - just calls IoCompleteRequest(...).
ftd_dev_dispatch(...) - Device dispatch routine, just passed the IRP down.
ftd_ioctl(...) - Determines if this ioctl is for a lg, and calls ftd_lg_ioctl.  Since we do not handle ioctls for a device we just call the above function.
ftd_nt_lg_close(...) - handles NT specific close functionality for a lg_close call.
ftd_nt_lg_open(...) - handles NT specific close functionality for a lg_open call.
ftd_open(...) - handles both ctl and lg open from the NT dispatch table and calls the correct function.
ftd_close(...) - handles both ctl and lg close from the NT dispatch table and calls the correct function.
ftd_iodone_generic(...) - As with UNIX called on a i/o completion for a read or a write if not journaling, it updates statistics.
ftd_iodone_journal(...) - As with UNIX called on a i/o completion for a journal write, NT puts the i/o in the completion queue.
ftd_do_read(...) - Read dispatch routine.
ftd_do_write(...) - Write dispatch routine.
ftd_flush_lrdb(...) - If a IRP would update the lrdb, put it on the pstore queue.
ftd_nt_del_lg(...) - does NT specific cleanup if a lg is closed/fails.
ftd_nt_start_lg_thread(...) - creates structures necessary and the commit and sync threads.
ftd_nt_add_lg(...) - creates a lg device and its symbolic links.
ftd_nt_detach_device(...) - utitlity function to check if a device is mounted, if not detach from the device stack.
ftd_nt_del_device(...) - stops the pstore thread for a device, releases resources.
ftd_nt_start_dev_thread(...) - creates device specific resources, starts the pstore thread for this device.
ftd_nt_add_device(...) - attaches to a devices' stack.
ftd_find_device(...) - confirms a device exists.
ftd_init_dev_ext(...) - initalizes a device extension that is attached.
ftd_init_ext_ext(...) - initalizes a device extension.
ftd_init_lg_ext(...) - initalizes a lg extension.

ftd_bab.c - creates bab memory manager and bab memory (see the MAXMEM NT hack below)

The BAB manager memory is always allocated using NonPagedPool, but the BAB blocks are allocated using two different types of memory:

ExAllocatePool(PagedPool, ...) which limits you to about 140 megs (but should be less).
or memory set aside from the OS, using the /MAXMEM switch this is up to 2 Gigs.

ftd_bab_init(...) - passing in the maxmem parameter (read from the registry) determines what type of memory to use and this function chunks it up.
ftd_bab_map_memory(...) - Maps physcial to virtual memory when using MAXMEM type memory.
ftd_bab_unmap_memory(...) - UnMaps virtual memory pointers.

