
////////////////////////////////////////////////////////////////////////////////
//                                                                            
//   File Name:   Setup.rul                                                   
//                                                                            
//   Description: InstallShield script                                        
//                                                                            
//   Comments:    This script was generated based on the selections you made in
//                the Project Wizard.  Refer to the help topic entitled "Modify      
//                the script that the Project Wizard generates" for information
//                on possible next steps.
//
////////////////////////////////////////////////////////////////////////////////  

//----------------------------------------------------------------------------
// --== IMPORTANT ==--
//
// Two components where used for the replication server. One for Windows 2000
// and one for Windows NT4. Both component have the same display name but 
// different names. They are both invisible and only one is made visible when
// the OS is detected before getting in the Component Tree window.
//-----------------------------------------------------------------------------

//#define Debug  // this enables the install to run on any OS with any priviliges.  

// Include header files
    
#include "ifx.h"
#include "rebrandable.h"
    
////////////////////// string defines ////////////////////////////

//////////////////// installation declarations ///////////////////

// ----- DLL function prototypes -----

// your DLL function prototypes      
prototype INT DtcTDMFInstall.GetIPCount();
prototype INT DtcTDMFInstall.GetIPAddressFromList(NUMBER, BYREF STRING);

// ---- script function prototypes -----

// your script function prototypes

prototype BOOL ValidateOS();
prototype BOOL PortNumberIsValid(string);
prototype NUMBER BABSizeSelectionDlg(byref string);  
prototype NUMBER IPAddressSelectionDlg(byref string);  

prototype NUMBER StopService(string);

    // your global variables
                                                                        
#define ReplServer2000Component    "Replication Server 2000"   
#define ReplServerNT4Component     "Replication Server NT4"                               
#define InstallDllFilename         "DtcTDMFInstall.dll"
#define HostIdKey                  "SOFTWARE\\Softek\\Dtc\\CurrentVersion\\HostID"

// Global variables            

string ReplicationServerComponent;                      
string DtcIPAddress;
string ReplicationServerPortNb;
string InstalledDir;
string BABSize;
string UnusedString;
number IsUninstalling;
BOOL   CriticalErrorOccured;
string RegistrationKey;

// used for modify and repair and states which component are installed     
BOOL ReplicationServerInstalled; 

//---------------------------------------------------------------------------
// OnBegin
//
// The OnBegin event is called directly by the framework after the setup
// initializes.
//
// Note: This event will not be called automatically in a
// program...endprogram style setup.
//---------------------------------------------------------------------------
function OnBegin()
  number ComputerNameSize; 
  number Result;
  number Size;
  number Type; 
  string RegKey;
  string RegKeyOld;
  number MemorySize;  
begin
    // TODO: Perform custom initialization steps, check requirements, etc.
  CriticalErrorOccured = FALSE;  
  IsUninstalling = FALSE;         
                         
  UseDLL( SUPPORTDIR ^ InstallDllFilename ); 
  
  // Update Reg key location: Remove "Fujitsu"
  RegDBSetDefaultRoot(HKEY_LOCAL_MACHINE); 
  RegKeyOld = "SOFTWARE\\Fujitsu Softek";
  RegKey = "SOFTWARE\\Softek";
  if (RegDBKeyExist(RegKeyOld)) then
	if (RegDBCopyKeys(RegKeyOld, RegKey, HKEY_LOCAL_MACHINE, HKEY_LOCAL_MACHINE) >= ISERR_SUCCESS) then
      RegDBDeleteKey(RegKeyOld);
    endif;
  endif;  

  RegDBSetDefaultRoot(HKEY_CURRENT_USER); 
  RegKeyOld = "SOFTWARE\\Fujitsu Softek";
  RegKey = "SOFTWARE\\Softek";
  if (RegDBKeyExist(RegKeyOld)) then
	if (RegDBCopyKeys(RegKeyOld, RegKey, HKEY_CURRENT_USER, HKEY_CURRENT_USER) >= ISERR_SUCCESS) then
      RegDBDeleteKey(RegKeyOld);
    endif;
  endif;
  
  RegDBSetDefaultRoot(HKEY_LOCAL_MACHINE); 
  
  // Delete this key if it exist. It will be recreated by the 
  // application but if, for any reason, it points in the wrong
  // location the application will hang. The application
  // will recreate it properly upon startup
  RegKey = "SYSTEM\\CurrentControlSet\\Services\\TDMFANALYZER";
  RegDBDeleteKey(RegKey);     
  
  RegKey = "SOFTWARE\\Softek\\DTC\\CurrentVersion";
  if (RegDBGetKeyValueEx(RegKey, "InstallPath", Type, InstalledDir, Size) < 0) then
    InstalledDir = "";
  endif; 

  RegKey = "SOFTWARE\\Softek\\DTC\\CurrentVersion";
  if (RegDBGetKeyValueEx(RegKey, "DtcIP", Type, DtcIPAddress, Size) < 0) then
    if (GetIPAddressFromList(0, DtcIPAddress) != 0) then 
      DtcIPAddress = "";   
    endif;
  endif;    

  if (RegDBGetKeyValueEx(RegKey, "license", Type, RegistrationKey, Size) < 0) then
    RegistrationKey = "";   
  endif;     

  if (RegDBGetKeyValueEx(RegKey, "port", Type, ReplicationServerPortNb, Size) < 0) then
    ReplicationServerPortNb = "575";   
  endif;     
  
  RegKey = "SYSTEM\\CurrentControlSet\\Services\\DTCBlock\\Parameters";
  if (RegDBGetKeyValueEx(RegKey, "NUM_CHUNKS", Type, BABSize, Size) < 0) then
    GetSystemInfo(EXTENDEDMEMORY, MemorySize, UnusedString);
    MemorySize = MemorySize / 1024;   
    if (MemorySize >= 106) then
      BABSize = "64";
    elseif (MemorySize >= 53) then
      BABSize = "32";
    else
      BABSize = "0"; 
    endif;
  endif;
end;
 
//---------------------------------------------------------------------------
// OnEnd
//
// The OnEnd event is called at the end of the setup. This event is not
// called if the setup is aborted.
//---------------------------------------------------------------------------
function OnEnd()
begin
  UnUseDLL(InstallDllFilename);
                         
  // This will delete the DisplayVersion entry in the registry for uninstall.
  // This is done because we didn't want 'Click here for support information'
  // showing up under the Add/Remove entry for TDMF OSE. 
  if (!IsUninstalling) then
    RegDBSetDefaultRoot(HKEY_LOCAL_MACHINE);
    RegDBDeleteValue("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\" + INSTANCE_GUID, "DisplayVersion");
  endif; 
  // Setup the Uninstall Icon
  if (!IsUninstalling) then
    RegDBSetDefaultRoot(HKEY_LOCAL_MACHINE);
    RegDBSetKeyValueEx("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\" + INSTANCE_GUID, 
                       "DisplayIcon",
                       REGDB_STRING,
                       TARGETDIR ^ "dtc.ico",
                       -1);
  endif; 
end;

//////////////////////////////////////////////////////////////////////////////////////////
//                                                                           
//  FUNCTION:   OnFirstUIBefore                                            
//                                                                           
//  EVENT:      The OnFirstUIBefore event is called by OnShowUI when the setup is
//              running in first install mode. By default this event displays UI allowing
//              the end user to specify installation parameters.
//              
//              Note: This event will not be called automatically in a
//              program...endprogram style setup.                                                             
//
//////////////////////////////////////////////////////////////////////////////////////////
function OnFirstUIBefore()
    number  nResult;
    number  nLevel;
    number  nLoop; 
    string  szTitle, szMsg;
    string  svDir;
    string  szComponents, szTargetdir;
    string  szTargetDirAppendix;  
    number  ComputerNameSize;
begin	

    if ( ALLUSERS ) then   
        TARGETDIR = PROGRAMFILES ^ CompanyDirName ^ ApplicationDirName;
    else
        TARGETDIR = FOLDER_APPDATA ^ CompanyDirName ^ ApplicationDirName; 
    endif;

    if (InstalledDir != "") then // Target dir found in registry, use it.
      TARGETDIR = InstalledDir;
    endif;

    // Customize the default TARGETDIR for multi-instance application.
    // TODO: If you want something different customize the code below.	
    if( MAINT_OPTION = MAINT_OPTION_MULTI_INSTANCE  && MULTI_INSTANCE_COUNT > 0) then
        nLoop = 1;
        svDir = TARGETDIR;
        while(ExistsDir(TARGETDIR) = EXISTS)			
            NumToStr(szTargetDirAppendix,nLoop);
            TARGETDIR = svDir + szTargetDirAppendix;
            nLoop = nLoop + 1;
        endwhile;						
    endif;

    svDir = TARGETDIR; 
           
    // Make sure this key is removed. This key is created by the application
    // and not removed. It may create havoc in multiple NIC card environnment
    // if it exits. It is easier, because both the server and the collector
    // uses it and I feel more comfortable making it sure it is gone before
    // we start. This is also done in OnMaintUIBefore.
    RegDBSetDefaultRoot(HKEY_LOCAL_MACHINE);
    RegDBDeleteKey(HostIdKey);
    
    ComponentSelectItem (MEDIA, ReplServer2000Component, FALSE); 
    ComponentSelectItem (MEDIA, ReplServerNT4Component,  FALSE);  
    
    // Select which of the two replication server component to use 
    // depending on the OS and make it visible. If the OS is not NT4
    // the Win2k component will be shown. If the OS is not NT4 or
    // Win2k a message will be shown by the validation later. I would 
    // rather show a message to the user than silently block his choices.
    if (SYSINFO.WINNT.bWinNT4 = TRUE) then
      ReplicationServerComponent = ReplServerNT4Component;
      ComponentSelectItem (MEDIA, ReplicationServerComponent,  TRUE);
      ComponentSetData(MEDIA, ReplicationServerComponent, COMPONENT_FIELD_VISIBLE, TRUE, UnusedString);
      LogWriteCustomString("OS Type", "Windows NT4");
    else // if (SYSINFO.WINNT.bWin2000 = TRUE) then (Do not force it. Validation later.)
      ReplicationServerComponent = ReplServer2000Component; 
      ComponentSelectItem (MEDIA, ReplicationServerComponent, TRUE);
      ComponentSetData(MEDIA, ReplicationServerComponent, COMPONENT_FIELD_VISIBLE, TRUE, UnusedString);
      LogWriteCustomString("OS Type", "Windows 2000");
    endif;
  
// Beginning of UI Sequence
Dlg_Start:

Dlg_SdWelcome:
    szTitle = "";
    szMsg = "";
    nResult = SdWelcome( szTitle, szMsg );
    if (nResult = BACK) goto Dlg_Start;
    #ifdef Debug
    MessageBox(SetupDebugStr, WARNING);
    #endif
    #ifndef Debug
    if (Is(USER_ADMINISTRATOR, UnusedString) = FALSE) then
      MessageBox(AdminPrivilegesStr, SEVERE);
      abort;
    endif;
    #endif
    if (!ValidateOS()) then
      abort;
    endif;

Dlg_SdRegistrationKeyEdition:
    nResult = SdShowDlgEdit1 (RegistrationKeyDlgTitleStr, RegistrationKeyDlgDescStr, 
                              RegistrationKeyDlgLabelStr, RegistrationKey);
    if (nResult = BACK) goto Dlg_SdWelcome;
    
Dlg_SdIPAddressSelection:
    if (GetIPCount() > 1) then
      nResult = IPAddressSelectionDlg(DtcIPAddress); 
      if (nResult = BACK) goto Dlg_SdRegistrationKeyEdition;
    endif; 
    
Dlg_SdShowDlgEditReplicationPort:        
    nResult = SdShowDlgEdit1 (ReplicationPortDlgTitleStr, ReplicationPortDlgDescStr, 
                              PortDlgLabelStr, ReplicationServerPortNb);
    if (nResult = BACK) then
      if  (GetIPCount() > 1) goto Dlg_SdIPAddressSelection;
      goto  Dlg_SdRegistrationKeyEdition;
    endif;
       
    // Validate the port number
    if (!PortNumberIsValid(ReplicationServerPortNb)) then
      MessageBox(PortNotValidStr, SEVERE);
      goto Dlg_SdShowDlgEditReplicationPort;
    endif;
                                                 
Dlg_SdBABSizeSelection:                                                 
    nResult = BABSizeSelectionDlg(BABSize); 
    if (nResult = BACK) goto Dlg_SdShowDlgEditReplicationPort;   
                                                 
Dlg_SdAskDestPath2:
    szTitle = "";
    szMsg = "";
    nResult = SdAskDestPath2( szTitle, szMsg, svDir );
    TARGETDIR = svDir;
    if (nResult = BACK) goto Dlg_SdBABSizeSelection;

Dlg_ObjDialogs:
    nResult = ShowObjWizardPages( nResult );
    if (nResult = BACK) goto Dlg_SdAskDestPath2;
    
Dlg_SdStartCopy2:
    szTitle = "";
    szMsg = "";
    nResult = SdStartCopy2( szTitle, szMsg );	
    if (nResult = BACK) goto Dlg_ObjDialogs; 
    return 0;
end;
 
//---------------------------------------------------------------------------
// OnFirstUIAfter
//
// First Install UI Sequence - After Move Data
//
// The OnFirstUIAfter event called by OnShowUI after the file transfer
// of the setup when the setup is running in first install mode. By default
// this event displays UI that informs the end user that the setup has been
// completed successfully.
//
// Note: This event will not be called automatically in a
// program...endprogram style setup.
//---------------------------------------------------------------------------
function OnFirstUIAfter()
    STRING szTitle, szMsg1, szMsg2, szOpt1, szOpt2;
    NUMBER bvOpt1, bvOpt2;  
    number Result;
    string ErrorMsgStr;
    string ResultStr;
 begin

    ShowObjWizardPages(NEXT);
  
    szTitle = "";
    szMsg1 = ""; 
    szMsg2 = "";
    szOpt1 = "";
    szOpt2 = "";
	bvOpt1   = FALSE;
    bvOpt2   = FALSE;    
       
    if (CriticalErrorOccured) then
      MessageBox(CriticalErrorMsgStr, SEVERE);   
    endif;
    if ( BATCH_INSTALL ) then
    	SdFinishReboot ( szTitle , szMsg1 , SYS_BOOTMACHINE , szMsg2 , 0 );
    else
		  SdFinish ( szTitle , szMsg1 , szMsg2 , szOpt1 , szOpt2 , bvOpt1 , bvOpt2 );
		endif;
end;
 
//---------------------------------------------------------------------------
// OnMaintUIBefore
//
// Maintenance UI Sequence - Before Move Data
//
// The OnMaintUIBefore event is called by OnShowUI when the setup is
// running in maintenance mode. By default this event displays UI that
// allows the end user to add or remove components, repair currently
// installed components or uninstall the application.
//
// Note: This event will not be called automatically in a
// program...endprogram style setup.
//---------------------------------------------------------------------------
function OnMaintUIBefore()
    number	nResult, nType, nMediaFlags;
    string	szTitle, szMsg, szIgnore;
    number  ComputerNameSize;
begin
	                          
    // Select which of the two replication server component to use 
    // depending on the OS and make it visible
    if (SYSINFO.WINNT.bWinNT4 = TRUE) then
      ReplicationServerComponent = ReplServerNT4Component;
      ComponentSetData(MEDIA, ReplicationServerComponent, COMPONENT_FIELD_VISIBLE, TRUE, UnusedString);
    else // if (SYSINFO.WINNT.bWin2000 = TRUE) then (Do not force it. Validation later.)
      ReplicationServerComponent = ReplServer2000Component; 
      ComponentSetData(MEDIA, ReplicationServerComponent, COMPONENT_FIELD_VISIBLE, TRUE, UnusedString);
    endif;

    // Record what is already installed on the machine
    ReplicationServerInstalled = ComponentIsItemSelected (MEDIA, ReplicationServerComponent);     
    
    // Make sure this key is removed. This key is created by the application
    // and not removed. It may create havoc in multiple NIC card environnment
    // if it exits. It is easier, because both the server and the collector
    // uses it and I feel more comfortable making it sure it is gone before
    // we start. This is also done in OnFirstUIBefore. This must be done
    // only if both the server and the collector are not present.
    if (!ReplicationServerInstalled) then
      RegDBSetDefaultRoot(HKEY_LOCAL_MACHINE);
      RegDBDeleteKey(HostIdKey);
    endif;
     
	// nType defaults to MODIFY.
	nType = MODIFY;
    
// Beginning of UI Sequence
Dlg_Start:

	// Show Standard Maintenance Dialog
	Disable( BACKBUTTON );
	nType = SdWelcomeMaint( szTitle, szMsg, nType );   
	
	Enable( BACKBUTTON );
    nResult = NEXT;

    if (!ValidateOS()) then
      abort;
    endif;

	// Show Uninstall Confirmation Dialog
    if ( nType = REMOVEALL ) then 
        IsUninstalling = TRUE;
		nResult = MessageBox( SdLoadString( IFX_MAINTUI_MSG ), MB_YESNO );
		if (nResult != IDYES ) then
			goto Dlg_Start;
		endif;
	endif;          

Dlg_SdRegistrationKeyEdition:
	if ( nType = MODIFY ) then
      nResult = SdShowDlgEdit1 (RegistrationKeyDlgTitleStr, RegistrationKeyDlgDescStr, 
                                RegistrationKeyDlgLabelStr, RegistrationKey);
      if (nResult = BACK) goto Dlg_Start;
    endif;

Dlg_SdIPAddressSelection:
  	if ( nType = MODIFY ) then
      if (GetIPCount() < 2) then
        if (nResult = NEXT) goto Dlg_SdShowDlgEditReplicationPort;
        if (nResult = BACK) goto Dlg_SdRegistrationKeyEdition;
      endif; 
      nResult = IPAddressSelectionDlg(DtcIPAddress);
      if (nResult = BACK) goto Dlg_SdRegistrationKeyEdition;   
    endif;

Dlg_SdShowDlgEditReplicationPort:        
	if ( nType = MODIFY ) then
      nResult = SdShowDlgEdit1 (ReplicationPortDlgTitleStr, ReplicationPortDlgDescStr, 
                                PortDlgLabelStr, ReplicationServerPortNb); 
      if (nResult = BACK) goto Dlg_SdIPAddressSelection;   
      // Validate the port number
      if (!PortNumberIsValid(ReplicationServerPortNb)) then
        MessageBox(PortNotValidStr, SEVERE);
        goto Dlg_SdShowDlgEditReplicationPort;
      endif;
    endif;
                                                 
Dlg_SdBABSizeSelection:                                                 
	if ( nType = MODIFY ) then
      if (!ComponentIsItemSelected (MEDIA, ReplicationServerComponent)) then
        if (nResult = NEXT) goto Dlg_ObjDialogs;
        if (nResult = BACK) goto Dlg_SdShowDlgEditReplicationPort;
      endif;
      nResult = BABSizeSelectionDlg(BABSize); 
      if (nResult = BACK) goto Dlg_SdShowDlgEditReplicationPort;   
    endif;
                                                 
Dlg_ObjDialogs:
    nResult = ShowObjWizardPages( nResult );
    if ( ( nResult = BACK ) && ( nType != MODIFY ) ) goto Dlg_Start;
    if ( ( nResult = BACK ) && ( nType = MODIFY ) ) goto Dlg_SdBABSizeSelection;

	switch(nType)

        case REMOVEALL:
						
			// Ensure that all previously installed components are removed
			// for media that supports updating.
			MediaGetData( MEDIA, MEDIA_FIELD_MEDIA_FLAGS, nMediaFlags, szIgnore );
			
			if( nMediaFlags & MEDIA_FLAG_UPDATEMODE_SUPPORTED ) then
				ComponentRemoveAllInMediaAndLog();
			else
				ComponentRemoveAllInMedia();
			endif;

        case REPAIR:
			ComponentReinstall();

    endswitch;

end;

//---------------------------------------------------------------------------
// OnMaintUIAfter
//
// The OnMaintUIAfter event called by OnShowUI after the file transfer
// of the setup when the setup is running in maintenance mode. By default
// this event displays UI that informs the end user that the maintenance setup
// has been completed successfully.
//
// Note: This event will not be called automatically in a
// program...endprogram style setup.
//---------------------------------------------------------------------------
function OnMaintUIAfter()
    STRING szTitle, szMsg1, szMsg2, szOpt1, szOpt2;
    NUMBER bvOpt1, bvOpt2;   
    string ErrorMsgStr;
begin

    ShowObjWizardPages(NEXT);
    
    szTitle = SdLoadString(IFX_SDFINISH_MAINT_TITLE);    
    szMsg1  = SdLoadString(IFX_SDFINISH_MAINT_MSG1);
	  szMsg2 = "";    
    szOpt1 = "";
    szOpt2 = "";
  	bvOpt1   = FALSE;
    bvOpt2   = FALSE;    
    
    if (CriticalErrorOccured) then
      MessageBox(CriticalErrorMsgStr, SEVERE);   
    endif;
    if ( BATCH_INSTALL ) then
    	SdFinishReboot ( szTitle , szMsg1 , SYS_BOOTMACHINE , szMsg2 , 0 );
    else    
      SdFinish ( szTitle , szMsg1 , szMsg2 , szOpt1 , szOpt2 , bvOpt1 , bvOpt2 );
    endif;
end;    
    
// Script functions    
     
//----------------------------------------------------------------------------
// ValidateOS
//
// This functions verifies, depending on the component selected, if the user
// is running the correct OS.                                                    
//----------------------------------------------------------------------------
function BOOL ValidateOS()
begin
  #ifndef Debug     
  if (SYSINFO.WINNT.bWin2000 = FALSE && SYSINFO.WINNT.bWinNT4 = FALSE && SYSINFO.WINNT.bWinXP = FALSE) then   
    MessageBox(OSForReplicatorStr, SEVERE);
    return FALSE;
  endif;
  #endif 
  return TRUE;
end;

//----------------------------------------------------------------------------
// PortNumberIsValid
//
// Validates that the port number does not contain illegal characters and that
// it is in the range of 0 and 65535
//----------------------------------------------------------------------------
function BOOL PortNumberIsValid(InitialPortNb)
  number nPortNb;
  string sPortNb;
begin 
  // Check for illegal characters. If we convert to a number
  // and then back to a string we should get the same thing
  // unless there where non-numeric characters in the string
  StrToNum(nPortNb, InitialPortNb);
  NumToStr(sPortNb, nPortNb);
  if (sPortNb != InitialPortNb) then
    return FALSE;
  endif; 
  // check if the PortNb is in the allowed range
  if (nPortNb < 0 || nPortNb > 65535) then
    return FALSE;
  endif;
  return TRUE;   
end;  

//----------------------------------------------------------------------------
// BABSizeSelectionDlg
//   
// Shows a dialog for the user to choose a BAB size.
// Returns in the parameter a number corresponding to the BAB size. 0 means
// it is a secondary server
//----------------------------------------------------------------------------
function NUMBER BABSizeSelectionDlg(BABSizeParam)
  LIST listBABSizes, listComponents;
  STRING szSaveMEDIAValue, BABSizeString;
  LONG   nResult;
  NUMBER DlgResult;
  BOOL   bSelected; 
  NUMBER MemorySize;  
begin    
  GetSystemInfo(EXTENDEDMEMORY, MemorySize, UnusedString);
  MemorySize = MemorySize / 1024;  
  listBABSizes = ListCreate(STRINGLIST);
  ListAddString(listBABSizes, "0 MB", AFTER); 
  if (MemorySize > 53) then
    ListAddString(listBABSizes, "32 MB", AFTER);
    if (MemorySize > 106) then 
      ListAddString(listBABSizes, "64 MB", AFTER); 
      if (MemorySize >= 160) then
        ListAddString(listBABSizes, "96 MB", AFTER);
        if (MemorySize >= 213) then 
          ListAddString(listBABSizes, "128 MB", AFTER);  
          if (SYSINFO.WINNT.bWinNT4 = FALSE) then
          if (MemorySize >= 266) then
            ListAddString(listBABSizes, "160 MB", AFTER);   
            if (MemorySize >= 320) then
              ListAddString(listBABSizes, "192 MB", AFTER); 
                if (MemorySize >= 1024) then
                ListAddString(listBABSizes, "224 MB", AFTER);
              endif;
            endif;
          endif;
        endif;
      endif;  
    endif;
  endif; 
  endif;   
  
  // Save the value of the system variable MEDIA so it can
  // be restored for later calls to transfer data.
  szSaveMEDIAValue = MEDIA;
  // Specify a name for the script-created component set.
  MEDIA = "BABSizes";
  BABSizeParam = BABSizeParam + " MB"; 
  nResult = ListGetFirstString(listBABSizes, BABSizeString);
  while (nResult != END_OF_LIST)
    ComponentAddItem(MEDIA, BABSizeString, 0, FALSE); 
    if (BABSizeString = BABSizeParam) then
      ComponentSelectItem (MEDIA, BABSizeString, TRUE); 
    endif;
    nResult = ListGetNextString(listBABSizes, BABSizeString);
  endwhile;
  DlgResult = SdAskOptionsList(BABSizeDlgTitle, BABSizeDlgText, "" , EXCLUSIVE);
  bSelected = FALSE;
  nResult = ListGetFirstString(listBABSizes, BABSizeString);   
  bSelected = ComponentIsItemSelected (MEDIA , BABSizeString);
  while ((nResult != END_OF_LIST) && !bSelected);
    nResult = ListGetNextString(listBABSizes, BABSizeString);
    bSelected = ComponentIsItemSelected (MEDIA , BABSizeString);
  endwhile;   
  BABSizeParam = BABSizeString;
  StrReplace(BABSizeParam, " MB", "", 0);
  // Release the list from memory.
  ListDestroy (listBABSizes);
  // Restore MEDIA to its previous value for file transfer.
  MEDIA = szSaveMEDIAValue;
  return DlgResult;
end;  
         
//----------------------------------------------------------------------------
// IPAddressSelectionDlg
//   
// Shows a dialog for the user to choose a BAB size.
// Returns in the parameter a number corresponding to the BAB size. 0 means
// it is a secondary server
//----------------------------------------------------------------------------
function NUMBER IPAddressSelectionDlg(IPAddressParam)
  LIST listIPAddress, listComponents;
  STRING szSaveMEDIAValue, IPAddressString;
  LONG   nResult;
  NUMBER DlgResult, i;
  BOOL   bSelected; 
begin    
  listIPAddress = ListCreate(STRINGLIST);
  for i = 0 to GetIPCount()      
    if (GetIPAddressFromList(i, IPAddressString) = 0) then
      ListAddString(listIPAddress, IPAddressString, AFTER); 
    endif;
  endfor; 
  // Save the value of the system variable MEDIA so it can
  // be restored for later calls to transfer data.
  szSaveMEDIAValue = MEDIA;
  // Specify a name for the script-created component set.
  MEDIA = "IPAddress";
  nResult = ListGetFirstString(listIPAddress, IPAddressString);
  while (nResult != END_OF_LIST)
    ComponentAddItem(MEDIA, IPAddressString, 0, FALSE); 
    if (IPAddressString = IPAddressParam) then
      ComponentSelectItem (MEDIA, IPAddressString, TRUE); 
    endif;
    nResult = ListGetNextString(listIPAddress, IPAddressString);
  endwhile;
  DlgResult = SdAskOptionsList(IPAddressDlgTitle, IPAddressDlgText, "" , EXCLUSIVE);
  bSelected = FALSE;
  nResult = ListGetFirstString(listIPAddress, IPAddressString);   
  bSelected = ComponentIsItemSelected (MEDIA , IPAddressString);
  while ((nResult != END_OF_LIST) && !bSelected);
    nResult = ListGetNextString(listIPAddress, IPAddressString);
    bSelected = ComponentIsItemSelected (MEDIA , IPAddressString);
  endwhile;   
  IPAddressParam = IPAddressString;
  // Release the list from memory.
  ListDestroy (listIPAddress);
  // Restore MEDIA to its previous value for file transfer.
  MEDIA = szSaveMEDIAValue;
  return DlgResult;
end;  

 
//----------------------------------------------------------------------------
// StopService
//----------------------------------------------------------------------------
function NUMBER StopService(ServiceName)
  number State; 
  number Seconds;
  number Result;  
  string s;
begin
  Result = ServiceGetServiceState(ServiceName, State);
  if (Result >= ISERR_SUCCESS) then
    if (State != SERVICE_STOPPED) then
      ServiceStopService(ServiceName);
      Seconds = 0;
      repeat 
        Delay(1); // wait 1 second   
        Seconds += 1;
        ServiceGetServiceState(ServiceName, State);
      until (Seconds = 120 || State = SERVICE_STOPPED);
    endif;   
    if (State != SERVICE_STOPPED) then  
      MessageBox("The " + ServiceName + " service could not be stopped", SEVERE);
      CriticalErrorOccured = TRUE;
    endif;
  else
    MessageBox("The " + ServiceName + " service could not be stopped", SEVERE);
    CriticalErrorOccured = TRUE;
  endif;                        
  return Result;
end;     
 
//---------------------------------------------------------------------------
// OnUpdateUIBefore
//
// Update UI Sequence - Before Move Data
//
// The OnUpdateUIBefore event is called when the setup is running in update
// mode. By default this event displays UI that allows the end user to
// update the application to the current version.
//
// Note: This event will not be called automatically in a
// program...endprogram style setup.
//---------------------------------------------------------------------------
function OnUpdateUIBefore()
	string szTitle, szMsg, szIgnore, szVersionInstalled, szVersionSupported, szVersionUpdate;
	number nVersionInstalled;
	number nIgnore, nId, nMediaFlags;
	number nResult;
	string svVersionInstalled; 
 	number nvVersionResult, nvMajor, nvMinor, nvBuild;
begin
	// Determine the update media type.	
	MediaGetData( MEDIA, MEDIA_FIELD_MEDIA_FLAGS, nMediaFlags, szIgnore );

	// Compare Versions
	nResult = VerProductCompareVersions();

	// Make sure that valid data was returned by VerProductCompareVersions
	if( nResult < ISERR_SUCCESS ) then
		szMsg = SdLoadString( IDS_IFX_ERROR_UPDATE_VERSION_COMPARE_FAILURE );
		MessageBox( szMsg, SEVERE );
		abort;
	endif;

	// Make sure that the product is installed.
	if( nResult = VERSION_COMPARE_RESULT_NOT_INSTALLED ) then
		// Note: This result should occur only for differential media, since OnFirstUIBefore
		// will be called by default for non-differential media in this case.
		szMsg = SdLoadString( IDS_IFX_ERROR_UPDATE_PRODUCT_NOT_INSTALLED );
		SdSubstituteProductInfo( szMsg );
		MessageBox( szMsg, SEVERE );
		abort;
	endif;	

	// Check whether the update is older than the currently installed version.
	if( nResult = VERSION_COMPARE_RESULT_OLDER ) then
		szMsg = SdLoadString( IDS_IFX_ERROR_UPDATE_NOT_APPROPRIATE );
		SdSubstituteProductInfo( szMsg );
		MessageBox( szMsg, SEVERE );
		abort;
	endif;

	// Verify that this update is appropriate for the version of the application that is installed.
	if( nResult = VERSION_COMPARE_RESULT_NEWER_NOT_SUPPORTED ) then
		szMsg = SdLoadString( IDS_IFX_ERROR_UPDATE_NOT_SUPPORTED );
		SdSubstituteProductInfo( szMsg );
		MessageBox( szMsg, SEVERE );
		abort;
	endif;

	// Check whether the update is needed.
	if( nResult = VERSION_COMPARE_RESULT_SAME ) then
		// Note: This result should occur only for differential media, since the setup
		// will display OnMaintUIBefore or OnFirstUIBefore by default if the versions match
		// for full setup media.
		szMsg = SdLoadString( IDS_IFX_WARNING_UPDATE_NOT_NEEDED );
		SdSubstituteProductInfo( szMsg );
		if( MessageBox( szMsg, MB_ICONEXCLAMATION | MB_YESNO ) != IDYES ) then
			abort;
		endif;
	endif;

	// Automatically select newly added components, do this before UI sequence in case so that
	// if a component dialog is added, it reflects newly selected components.
	ComponentSelectNew( MEDIA, TRUE );

	// TODO: Enable this line if you want the update to to automatically uninstall
	// any components that are not contained in the media but are listed in the 
	// log file.
	// ComponentRemoveAllInLogOnly();
           
// Beginning of UI Sequence
Dlg_Start:

Dlg_SdWelcome:
	szTitle = "";
    szMsg = SdLoadString( IDS_IFX_SDWELCOMMESSAGE_UPDATE_WELCOME );
    // Re-format version number
	VerProductGetInstalledVersion (svVersionInstalled);
	VerProductStrToNum (nvVersionResult, svVersionInstalled);
	nvMajor = nvVersionResult >> 24;
	nvMinor = (nvVersionResult >> 16) & 0xFF;
	nvBuild = nvVersionResult & 0xFFFF;
	Sprintf(svVersionInstalled, "%ld.%ld.%ld", nvMajor, nvMinor, nvBuild);
    StrReplace(szMsg, "%VI", svVersionInstalled, 0);
    nResult = SdWelcome( szTitle, szMsg );
    if (nResult = BACK) goto Dlg_Start;

Dlg_SdRegistrationKeyEdition:
    nResult = SdShowDlgEdit1 (RegistrationKeyDlgTitleStr, RegistrationKeyDlgDescStr, 
                              RegistrationKeyDlgLabelStr, RegistrationKey);
    if (nResult = BACK) goto Dlg_SdWelcome;
    
Dlg_SdIPAddressSelection:
    if (GetIPCount() < 2) then
      if (nResult = NEXT) goto Dlg_ObjDialogs;
      if (nResult = BACK) goto Dlg_SdRegistrationKeyEdition;
    endif; 
    nResult = IPAddressSelectionDlg(DtcIPAddress); 
    if (nResult = BACK) goto Dlg_SdRegistrationKeyEdition;  
    
Dlg_ObjDialogs:
    nResult = ShowObjWizardPages( nResult );
    if (nResult = BACK) goto Dlg_SdIPAddressSelection; 

	if( nMediaFlags & MEDIA_FLAG_FORMAT_DIFFERENTIAL ) then
		// Differential installs patch media.
		ComponentPatch();
	else
		// Update reinstalls (updates) all components in media.
		ComponentReinstall();
	endif;

end;

// --- include script file section ---

#include "ComponentEvents.rul"
