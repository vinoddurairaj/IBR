#! /usr/local/bin/perl5
eval 'exec perl -S $0 ${1+"$@"}'
        if $running_under_some_shell;

########################################
# Preliminaries
#
use Getopt::Std;
use qaLib;
use strict;

require 'Random.pl';
require 'sys/syscall.ph';

########################################
# Initialize constants
#
my $DFLT_MeanAccessPeriod = 1.5;	 		# expected time between write accesses, in seconds
my $DFLT_AccessPeriodVariance = 1.5;		# variance of time between write accesses, in seconds
my $DFLT_MeanBlocksPerAccess = 5;			# expected size of a given I/O access, in application blocks
my $DFLT_SectorsPerBlock = 8 * 1024 / 512;	# application block size, in sectors.  Default is 16 (8 Kbytes)
my $DFLT_TestDuration = 0;					# duration of test, in seconds; or 0 if no limit
my $DFLT_ProbabilityOfWrite = 0.1;			# probability of a given block hit being a write hit
my $DFLT_ProbabilityOfReadWrite = 0.0;		# probability that a write is preceeded by a read
my $logicalGroup = -1;

########################################
# Process arguments
#
my $scriptName = $0;
getopts('DQRS:b:p:qr:s:t:v:w:') || Usage();
$#ARGV == 0 || Usage();

########################################
# Initialize parameters
#
my $probabilityOfWrite		= ((defined $::opt_w) ? ($::opt_w / 100.0) : $DFLT_ProbabilityOfWrite);
my $probabilityOfReadWrite	= ((defined $::opt_r) ? ($::opt_r / 100.0) : $DFLT_ProbabilityOfReadWrite);
my $meanAccessPeriod		= ((defined $::opt_p) ? $::opt_p : $DFLT_MeanAccessPeriod);
my $accessPeriodVariance	= ((defined $::opt_v) ? $::opt_v : $DFLT_AccessPeriodVariance);
my $meanBlocksPerAccess		= ((defined $::opt_b) ? $::opt_b : $DFLT_MeanBlocksPerAccess);
my $sectorsPerBlock			= ((defined $::opt_s) ? $::opt_s : $DFLT_SectorsPerBlock);
my $testDuration			= ((defined $::opt_t) ? $::opt_t : $DFLT_TestDuration);
my $RNGSeed					= ((defined $::opt_S) ? $::opt_S : time);
my $doRandomAccesses		= defined $::opt_R;
$::opt_q						= 1 if ($::opt_Q);

my $forever;
my $timeout;
if ($testDuration == 0) {
	$forever = 1;
}
else {
	$forever = 0;
	$timeout = time + $testDuration;
}

srand($RNGSeed);


########################################
# Validate parameters
#
(0.0 <= $probabilityOfWrite && $probabilityOfWrite <= 1.0)
	|| die "Invalid percentage of write operations specified (-w%s)\n", $::opt_w;
(0.0 <= $probabilityOfReadWrite && $probabilityOfReadWrite <= 1.0)
	|| die "Invalid percentage of read/write operations specified (-r%s)\n", $::opt_r;
($sectorsPerBlock > 0 && int($sectorsPerBlock) == $sectorsPerBlock)
	|| die "Application block size (-s<size>) must be an integer greater than 0";
($meanAccessPeriod >= 0.0)
	|| die "Mean access period (-p<period>) must be non-negative.";
($accessPeriodVariance >= 0.0)
	|| die "Access period variance (-v<variance>) must be non-negative.";
($meanBlocksPerAccess >= 0.0)
	|| die "Mean access size (-b<accesssz>) must be non-negative.";

########################################
# Initialize statistics
#
my $startTime	= 0;			# Time started
my $endTime	    = 0;			# Time ended
my $sleepTotal  = 0;			# Total number of seconds spent sleeping
my $readCount	= 0;			# Number of read operations performed
my $writeCount	= 0;			# Number of write operations performed
my $burstCount	= 0;			# Number of bursts
my $readTotal	= 0;			# Total number of sectors read
my $writeTotal	= 0;			# Total number of sectors written
my $writeTime   = 0;			# Time spent writing (microseconds)
my $readTime    = 0;			# Time spent reading (microseconds)

########################################
# Validate the device and open it
#
my $device = $ARGV[0];
$device =~ s|^/dev/r?dsk/||;

# Check to see whether or not the device is mounted (if it is, we die
# in CheckForDeviceMounted.
#
CheckForDeviceMounted('/dev/dsk/' . $device);

my $lastDeviceSector;
my $isqdsDevice;
$device = '/dev/rdsk/' . $device;
if ($device =~ m|/dev/rdsk/qds|) {
	$lastDeviceSector = GetqdsDeviceGeometry($device) - 1;
	$isqdsDevice = 1;
}
else {
	$lastDeviceSector = GetStdDeviceGeometry($device) - 1;
	$isqdsDevice = 0;
}

my $openMode;
if    ($probabilityOfWrite == 0.0)                                   { $openMode = '<'; }
elsif ($probabilityOfWrite == 1.0 && $probabilityOfReadWrite == 0.0) { $openMode = '>'; }
else                                                                 { $openMode = '+>' }

$| = 1;
open(DEVICE, $openMode . $device)
	|| die "$device: open failed: $!";

########################################
# Get ready for our loop.
#
$startTime = time;
my $ioBuffer = '\0' x ($sectorsPerBlock * 512);
BeginReport();
$SIG{'INT'} = $SIG{'QUIT'} = 'SigHandler';

########################################
# Start the timing loop.
#
while ($forever || (time <= $timeout)) {
	my($blocksAccessed, $startingSector, $writing, $readingAndWriting, $sleepTime, $i);
	$burstCount++;
	GatherqdsStats($device) if ($isqdsDevice);

	# Generate a cluster of blocks to hit
	#
	do {
		$blocksAccessed = int(NegExp($meanBlocksPerAccess) + .5);
	} while ($blocksAccessed == 0);

	if ($doRandomAccesses) {

		# Random access
		#
		for ($i = 0; $i < $blocksAccessed; $i++) {
			# For each block in the cluster,
			#  choose the location of the block (avoid sector 0)...
			#
			$startingSector = int(rand($lastDeviceSector/$sectorsPerBlock)) * $sectorsPerBlock + 1;

			if (($lastDeviceSector - $startingSector + 1) < $sectorsPerBlock) {
				$startingSector = $lastDeviceSector - $sectorsPerBlock + 1;
			}

			# ...do a write ($probabilityOfWrite * 100)% of the time, otherwise a read...
			#
			$writing = (rand(1.0) <= $probabilityOfWrite ? 1 : 0);
			$readingAndWriting = ($writing ? (rand(1.0) <= $probabilityOfReadWrite ? 1 : 0) : 0);

			#  ...and hit it.
			#
			if (!$writing || $readingAndWriting) {
				doRead($startingSector, $sectorsPerBlock, 1);
			}
			if ($writing || $readingAndWriting) {
				doWrite($startingSector, $sectorsPerBlock, 1);
			}
			Log("\n");
		}
	}
	else {
		# Sequential access
		#

		# If the number of sectors we want to access is greater than those available,
		# adjust our desires downward accordingly.
		#
		if ($blocksAccessed > ($lastDeviceSector / $sectorsPerBlock)) {
			$blocksAccessed = ($lastDeviceSector / $sectorsPerBlock);
		}

		# Choose the starting location of the I/O operation. We need to avoid sector 0, and
		# avoid overrunning the end of the device...
		#
		$startingSector = int(rand($lastDeviceSector - 1)) + 1;
		if (($lastDeviceSector - $startingSector + 1) < $blocksAccessed * $sectorsPerBlock) {
			$startingSector = $lastDeviceSector - ($blocksAccessed * $sectorsPerBlock) + 1;
		}

		$writing = (rand(1.0) <= $probabilityOfWrite ? 1 : 0);
		$readingAndWriting = ($writing ? (rand(1.0) <= $probabilityOfReadWrite ? 1 : 0) : 0);

		#  ...and hit it
		if (!$writing || $readingAndWriting) {
			doRead($startingSector, $sectorsPerBlock, $blocksAccessed);
		}

		if ($writing || $readingAndWriting) {
			doWrite($startingSector, $sectorsPerBlock, $blocksAccessed);
		}
	}

	# Now take a nap for a while.
	#
	$sleepTime = Normal($meanAccessPeriod, $accessPeriodVariance);
	$sleepTime = 0.0 if ($sleepTime < 0.0);
	my $timeNow = time;

	if (! $forever) {
		if ($timeNow > $timeout) {
			# We should already be done.
			last;
		}

		if ($timeNow + $sleepTime > $timeout) {
			# We would sleep past the timeout, so just sleep until the timeout.
			#
			$sleepTime = $timeout - $timeNow;
		}
	}
	$sleepTotal += $sleepTime;
	Log("Sleeping %lf seconds...", $sleepTime);
	if ($isqdsDevice) {
		while ($sleepTime > 1.0) {
			uSleep(1000000.0);
			$sleepTime -= 1.0;
			GatherqdsStats($device);
		}
		uSleep($sleepTime * 1000000.0);
	}
	else {
		uSleep($sleepTime * 1000000.0);
	}
	Log("\n");
}
close DEVICE;
$endTime = time;

Log("\n");
EndReport();

exit 0;


##############################################################################
# Subroutines & Functions
#

sub doRead {
	my($startingSector, $sectorsPerBlock, $blocksAccessed) = @_;
	my($i);

	Log("Reading %8d sectors: %8d - %8d.  ", $sectorsPerBlock * $blocksAccessed, $startingSector,
		$startingSector + $sectorsPerBlock * $blocksAccessed - 1);
	seek(DEVICE, $startingSector * 512, 0);
	for ($i = 0; $i < $blocksAccessed; $i++) {
		$readTime += TimeExecution( 'sysread(DEVICE, $ioBuffer, $sectorsPerBlock * 512);'  );
		GatherqdsStats($device) if ($isqdsDevice);
	}
	$readCount++;
	$readTotal += $blocksAccessed * $sectorsPerBlock;
}

sub doWrite {
	my($startingSector, $sectorsPerBlock, $blocksAccessed) = @_;
	my($i,$s);

	Log("Writing %8d sectors: %8d - %8d.  ", $sectorsPerBlock * $blocksAccessed, $startingSector,
		$startingSector + $sectorsPerBlock * $blocksAccessed - 1);
	seek(DEVICE, $startingSector * 512, 0);
	for ($i = 0; $i < $blocksAccessed; $i++) {
		$writeTime += TimeExecution( 'syswrite(DEVICE, $ioBuffer, $sectorsPerBlock * 512);'  );
		GatherqdsStats($device) if ($isqdsDevice);
	}
	$writeCount++;
	$writeTotal += $blocksAccessed * $sectorsPerBlock;
}

sub TimeExecution {
	my($stmt) = @_;
	my($before_timeVal, $after_timeVal, $markBefore, $markAfter)
		= ('\0' x 8,  '\0' x 8, 0, 0);

	syscall(&SYS_gettimeofday, $before_timeVal, 0) && die "syscall failed: $!";

	eval $stmt || die "Statement: '$stmt' failed: $!\n";

	syscall(&SYS_gettimeofday, $after_timeVal, 0) && die "syscall failed: $!,";
	my($beforeTv_sec, $beforeTv_usec) = unpack('l2', $before_timeVal);
	my($afterTv_sec, $afterTv_usec) = unpack('l2', $after_timeVal);
	$markBefore = (($beforeTv_sec - $startTime) * 1000000) + $beforeTv_usec;
	$markAfter  = (($afterTv_sec  - $startTime) * 1000000) + $afterTv_usec;
	$markAfter - $markBefore;
}

sub BeginReport {
	if ( ! $::opt_q) {
		my($name) = ($scriptName);
		$name =~ s|^.*/([^/]+)$|$1|;
		$name =~ s|\.[^.]*$||;
		printf "$name ($$)\n";
		printf "%-40.40s: %s\n",	'Device',							$device;
		printf "%-40.40s: %s\n",	'Device Size (sectors)',			$lastDeviceSector + 1;
		printf "%-40.40s: %s\n",	'Access Patterns',					$doRandomAccesses ? 'Random' : 'Sequential';
		printf "%-40.40s: %lf\n",	'Mean Access Period (seconds)',		$meanAccessPeriod;
		printf "%-40.40s: %lf\n",	'Access Period Variance (seconds)',	$accessPeriodVariance;
		printf "%-40.40s: %lf\n", 	'Mean Access Size (blocks)',		$meanBlocksPerAccess;
		printf "%-40.40s: %d\n",	'Sectors Per Block',				$sectorsPerBlock;
		printf "%-40.40s: %l.1f%%\n", 'Percentage of Write Operations',	$probabilityOfWrite * 100.0;
		printf "%-40.40s: %l.1f%%\n", 'Percentage of Reads Before Writes',	$probabilityOfReadWrite * 100.0;
		printf "%-40.40s: %d\n",	'Random Number Seed',				$RNGSeed;
		printf "%-40.40s: %s\n",	'Time Limit',  ($forever ? 'None'
													: sprintf("%02d:%02d:%02d\n", $testDuration / 3600,
															  ($testDuration % 3600) / 60, $testDuration % 60));
	}
}

sub EndReport {
	$SIG{'INT'} = $SIG{'QUIT'} = 'IGNORE';

	my $runningTime = $endTime - $startTime;
	if (! $::opt_q) {
		printf "%-40.40s: %s\n", 'Time started', "" . localtime($startTime);
		printf "%-40.40s: %s\n", 'Time ended', "" . localtime($endTime);
		printf "%-40.40s: %02d:%02d:%02d\n", 'Total running time', $runningTime / 3600,
			($runningTime % 3600) / 60, $runningTime % 60;

		printf "%-40.40s: %lf\n", 'Total number of seconds spent sleeping', $sleepTotal;
		printf "%-40.40s: %d\n", 'Number of read operations performed', $readCount;
		printf "%-40.40s: %d\n", 'Number of write operations performed', $writeCount;
		printf "%-40.40s: %d\n", 'Number of bursts', $burstCount;
		printf "%-40.40s: %d\n", 'Total number of sectors read', $readTotal;
		printf "%-40.40s: %d\n", 'Total number of sectors written', $writeTotal;
		printf "%-40.40s: %lf\n", 'Total time spent reading', $readTime / 1000000.0;
		printf "%-40.40s: %lf\n", 'Total time spent writing', $writeTime / 1000000.0;

		printf "%-40.40s: %lf\n", 'Avg. read performance (Kbytes/sec)',
			$readTime > 0.0  ? ($readTotal / 2) / ($readTime / 1000000.0) : 0.0;

		printf "%-40.40s: %lf\n", 'Avg. write performance (Kbytes/sec)',
			$writeTime > 0.0 ? ($writeTotal / 2) / ($writeTime / 1000000.0) : 0.0;

		printf "%-40.40s: %lf\n", 'Disk read throughput  (Kbytes/sec)', ($readTotal / 2) / $runningTime;
		printf "%-40.40s: %lf\n", 'Disk write throughput (Kbytes/sec)', ($writeTotal / 2) / $runningTime;

		if ($isqdsDevice) {
			printf "%-40.40s: %d\n", 'qds Statistics Samples:', $qaLib::qdsStatSamples;
			if ($qaLib::qdsStatSamples) {
				my $statName;
				foreach $statName (@qaLib::qdsStatNames) {
					printf "%-40.40s: %f\n", 'Avg. ' . $statName, ($qaLib::sum{$statName} * 1.0) / $qaLib::qdsStatSamples;
					printf "%-40.40s: %f\n", 'Max. ' . $statName, $qaLib::max{$statName} * 1.0;
				}
			}
		}
	}
	else {
		if (!$::opt_Q) {
			print
				'Device',                  "\t",
				'Device Size',             "\t",
				'Access Pattern',          "\t",
				'Mean Access Period',      "\t",
				'Period Variance',         "\t",
				'Mean Access Size',        "\t",
				'Sectors/Block',           "\t",
				'% Writes',                "\t",
				'% of Writes R/W',         "\t",
				'RNG Seed',                "\t",
				'Running Time',            "\t",
				'Seconds Slept',           "\t",
				'Reads',                   "\t",
				'Writes',                  "\t",
				'Bursts',                  "\t",
				'Sectors read',            "\t",
				'Sectors written',         "\t",
				'Time reading',            "\t",
				'Time writing',            "\t",
				'Read performance (K/sec)', "\t",
				'Write performance (K/sec)';

			if ($isqdsDevice) {
				my $statName;
				print "\tqds Samples";
				foreach $statName (@qaLib::qdsStatNames) {
					print "\tAvg. " . $statName;
					print "\tMax. " . $statName;
				}
			}
			print "\n";
		}

		$device =~ s|^/dev/rdsk/||;
		printf "%s\t",			 		$device;
		printf "%s\t",			 		$lastDeviceSector + 1;
		printf "%s\t",			 		$doRandomAccesses ? 'Random' : 'Sequential';
		printf "%lf\t",			 		$meanAccessPeriod;
		printf "%lf\t",			 		$accessPeriodVariance;
		printf "%lf\t",			 		$meanBlocksPerAccess;
		printf "%d\t",			 		$sectorsPerBlock;
		printf "%l.1f%%\t",		 		$probabilityOfWrite * 100.0;
		printf "%l.1f%%\t",		 		$probabilityOfReadWrite * 100.0;
		printf "%d\t",			 		$RNGSeed;
		printf "%02d:%02d:%02d\t",		$runningTime / 3600, ($runningTime % 3600) / 60, $runningTime % 60;
		printf "%lf\t",			 		$sleepTotal;
		printf "%d\t", 			 		$readCount;
		printf "%d\t", 			 		$writeCount;
		printf "%d\t", 			 		$burstCount;
		printf "%d\t", 			 		$readTotal;
		printf "%d\t", 			 		$writeTotal;
		printf "%lf\t",			 		$readTime / 1000000.0;
		printf "%lf\t",			 		$writeTime / 1000000.0;
		printf "%lf\t",			 		($readTime  ? ($readTotal  / 2) / ($readTime  / 1000000.0) : 0.0);
		printf "%lf",			 		($writeTime ? ($writeTotal / 2) / ($writeTime / 1000000.0) : 0.0);

		if ($isqdsDevice) {
			my $statName;
			print "\t", $qaLib::qdsStatSamples;
			foreach $statName (@qaLib::qdsStatNames) {
				print "\t", ($qaLib::sum{$statName} * 1.0) / $qaLib::qdsStatSamples;
				print "\t", $qaLib::max{$statName};
			}
		}
		print "\n";
	}
}

sub SigHandler {
	close DEVICE;
	$endTime = time;

	Log("\n");
	EndReport();
	exit(0);
}

sub Usage {
	printf "Usage: %s [options] <dev>\n", $scriptName;
	printf "\t-D:            print a running commentary on the action\n";
	printf "\t-R:            perform random-access bursts (default: false, sequential bursts)\n";
	printf "\t-p<period>:    mean access period in seconds (default: %f)\n", $DFLT_MeanAccessPeriod;
	printf "\t-v<variance>:  access period variance in seconds (default: %f)\n", $DFLT_AccessPeriodVariance;
	printf "\t-b<accesssz>:  mean access size in application blocks (default: %f)\n", $DFLT_MeanBlocksPerAccess;
	printf "\t-s<size>:      sectors per application block in 512 byte sectors (default: %d)\n", $DFLT_SectorsPerBlock;
	printf "\t-w<write%%>:    percent write accesses (default: %.1f%%)\n", $DFLT_ProbabilityOfWrite * 100.0;
	printf "\t-r<r/w%%>:      percentage of write accesses preceeded by read (default: %.1f%%)\n",
		$DFLT_ProbabilityOfReadWrite * 100.0;
	printf "\t-t<secs>:      run for <secs> seconds (default: forever)\n";
	printf "\t-S<seed>:      random number generator seed (default is the current time)\n";
	printf "\t-q:            quiet: generate only a two-line statistics report (includes header)\n";
	printf "\t-Q:            Quiet: generate only a one-line statistics report (no header)\n";
	die "\n";
}

sub Log {
	$::opt_D && printf @_;
}
