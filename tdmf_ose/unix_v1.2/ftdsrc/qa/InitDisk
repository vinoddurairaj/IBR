#! /usr/local/bin/perl5
eval 'exec perl -S $0 ${1+"$@"}'
        if $running_under_some_shell;

########################################
# Preliminaries
#
use Getopt::Std;
use qaLib;

########################################
# Initialize constants
#
$DFLT_SectorsPerBlock = 8 * 1024 / 512;	# application block size, in sectors.  Default is 16 (8KB)
$DFLT_FirstSector = -1;					# first sector to verify. Default is -1: 1 if s0, 0 otherwise
$DFLT_LastSector  = -1;					# last sector to verify, or -1 for all the rest (the default)

########################################
# Process arguments
#
$scriptName = $0;
getopts('DFRS:f:l:s:v') || Usage();
$#ARGV == 0 || Usage();

########################################
# Initialize parameters
#
$sectorsPerBlock		= ((defined $opt_s) ? $opt_s : $DFLT_SectorsPerBlock);
$firstSector			= ((defined $opt_f) ? $opt_f : $DFLT_FirstSector);
$lastSector				= ((defined $opt_l) ? $opt_l : $DFLT_LastSector);
$RNGSeed				= ((defined $opt_S) ? $opt_S : time);
$doRandomAccesses		= defined $opt_R;

srand($RNGSeed);


########################################
# Validate parameters
#
($sectorsPerBlock > 0 && int($sectorsPerBlock) == $sectorsPerBlock)
	|| die "Application block size (-s<size>) must be an integer greater than 0\n";


########################################
# Validate the device and open it
#
$device = $ARGV[0];
$device =~ s|^/dev/r?dsk/||;

# Check to see whether or not the device is mounted (if it is, we die
# in CheckForDeviceMounted.
#
CheckForDeviceMounted('/dev/dsk/' . $device);

$device = '/dev/rdsk/' . $device;
if ($device =~ m|/dev/rdsk/qds|) {
	($sliceStartSector, $sliceEndSector) = GetqdsDeviceGeometry($device);
	$isqdsDevice = 1;
}
else {
	($sliceStartSector, $sliceEndSector) = GetStdDeviceGeometry($device);
	$isqdsDevice = 0;
}

$| = 1;
open(DEVICE, '+>' . $device)
	|| die "$device: open failed: $!";

########################################
# Get ready for our loop.
#
$startTime = time;
$ioBuffer = sprintf('%8.8x', $startTime) x (512/8);
if ($firstSector < 0) {
	$firstSector = ($sliceStartSector == 0 ? 1 : 0);
}
if ($lastSector < 0) {
	$lastSector =  $sliceEndSector - $sliceStartSector;
}
($firstSector <= $lastSector)
	|| die "First sector ($firstSector) must be less than last sector ($lastSector).\n";

$numSectors = $lastSector - $firstSector + 1;
$numBlocks = int($numSectors / $sectorsPerBlock);
$numBlocks++ if ($numSectors % $sectorsPerBlock > 0);

if ($doRandomAccesses) {
	InitBlockMap(0, $numBlocks - 1);
	until (($block = PickBlockToWrite()) < 0) {
		$startingSector = $firstSector + ($block * $sectorsPerBlock);

		if ($block == ($numBlocks - 1) && ($numSectors % $sectorsPerBlock) > 0) {
			$sectorsToWrite = $numSectors % $sectorsPerBlock;
		}
		else {
			$sectorsToWrite = $sectorsPerBlock;
		}
		doWrite($startingSector, $sectorsToWrite, 1);
		MarkBlockWritten($block);
	}
}
else {
	doWrite($firstSector, $sectorsPerBlock, $numBlocks-1);
	if ($numSectors % $sectorsPerBlock == 0) {
		doWrite(($numBlocks-1) * $sectorsPerBlock + $firstSector, $sectorsPerBlock, 1);
	}
	else {
		doWrite(($numBlocks-1) * $sectorsPerBlock + $firstSector,
				$numSectors % $sectorsPerBlock, 1);
	}
}

# Now read 'em back
#
doRead($firstSector, 1, $numSectors)
	if $opt_v;

print "Initialized device.";
if ($isqdsDevice) {
	my $lg = ParseCfgFile(sprintf($qaLib::QDSConfFileTmplt, DetermineqdsLogicalGroup($device)));
	print " To verify mirror, kill the RMDs on $lg->{SECONDARY}{HOST} and run:\n";
	print "CheckMirror -f$firstSector -l$lastSector -K$startTime ";
	for $profileRef ( @{$lg->{PROFILES}} ) {
		next unless $profileRef;
		if ($profileRef->{DATASTARDEVICE} eq $device) {
			print "$profileRef->{MIRRORDISK}";
			last;
		}
	}
	print "\n";
}
else {
	print "\n";
}

close DEVICE;
exit 0;


##############################################################################
# Subroutines & Functions
#
sub InitializeSector {
	my($sNum, $ioBufOffset) = @_;
	
	substr($ioBuffer, $ioBufOffset, 512 - 8)     = sprintf('%8.8x', $startTime) x (512/8 - 1);
	substr($ioBuffer, $ioBufOffset, 8)           = sprintf("%08x", $sNum);
	substr($ioBuffer, $ioBufOffset + 512 - 8, 8) = sprintf("%08x", $sNum);
}

sub VerifySector {
	my($sNum, $sContents) = @_;

	if (   substr($sContents, 0, 8)       ne sprintf("%08x", $sNum)
		|| substr($sContents, 512 - 8, 8) ne sprintf("%08x", $sNum)) {

		printf STDERR ("Sector %d found to contain '%s' and '%s', should both be '%08x'\n",
					   $sNum,
					   substr($sContents, 0, 8),
					   substr($sContents, 512 - 8, 8),
					   $sNum);
	}

	if ( substr($sContents, 8, 512-(2*8)) ne sprintf('%8.8x', $startTime) x (512/8 - 2)) {

		my($key, $loc, $dword);
		$key = sprintf('%8.8x', $startTime);

		# We found a difference from what the sector contents should be.  Report it.
		#
		printf STDERR ("Found garbage in sector %d. Should be filled with '%s':\n", $sNum, $key);

		$loc = 0;
		while ($loc < 512 - 8) {

			# Find the next difference
			#
			do {
				$loc += 8;
				$dword = substr($sContents, $loc, 8);
			} until ($dword ne $key || $loc >= 512 - (2 * 8));

			if ($dword ne $key) {

				# Found a difference, report it.
				printf STDERR ("\tAt offset %3d, found '", $loc);
				do {
					printf STDERR ("%s", $dword);
					$loc += 8;
					$dword = substr($sContents, $loc, 8);
				} while ($loc < 512 - 8 && $dword ne $key);
				printf STDERR ("'\n");
			}
		}
	}
}

sub doWrite {
	my($startingSector, $sectorsPerBlock, $blocksAccessed) = @_;
	my($i,$s);

	seek(DEVICE, $startingSector * 512, 0);
	for ($i = 0; $i < $blocksAccessed; $i++) {
		GatherqdsStats($device) if $isqdsDevice && undef($opt_F);
		if ($isqdsDevice && undef($opt_F) && $sample{'WL %'} > 50) {
			Log("Writelog $sample{'WL %'}%% full.  Sleeping");

			do {
				Log(".");
				sleep 10;
				GatherqdsStats($device);
			} while ($sample{'WL %'} > 50);
		}

		for ($s = 0; $s < $sectorsPerBlock; $s++) {
			InitializeSector($startingSector + ($i * $sectorsPerBlock) + $s, $s * 512);
		}

		Log("Writing %d sectors: %8d - %8d.\n", $sectorsPerBlock,
			$startingSector + $sectorsPerBlock * $i,
			$startingSector + $sectorsPerBlock * ($i + 1) - 1);

		syswrite(DEVICE, $ioBuffer, $sectorsPerBlock * 512)
			|| die "$device: write failed: $!";
	}
}

sub doRead {
	my($startingSector, $sectorsPerBlock, $blocksAccessed) = @_;
	my($i, $s);

	Log("Reading %d sectors: %8d - %8d.\n", $sectorsPerBlock * $blocksAccessed, $startingSector,
		$startingSector + $sectorsPerBlock * $blocksAccessed - 1);
	seek(DEVICE, $startingSector * 512, 0);
	for ($i = 0; $i < $blocksAccessed; $i++) {
		sysread(DEVICE, $ioBuffer, $sectorsPerBlock * 512)
			|| die "$device: read failed: $!";

		for ($s = 0; $s < $sectorsPerBlock; $s++) {
			VerifySector($startingSector + ($i * $sectorsPerBlock) + $s, substr($ioBuffer, $s * 512, 512));
		}
	}
}


###############################
# Block map management routines
#
#	Initialize $firstBlock and $lastBlock, then call InitBlockMap.  Thereafter,
#	you can call PickBlockToWrite to return a randomly (more or less) chosen block
#	in the range [$firstBlock, $lastBlock] which has not been returned before.
#	If all blocks in the range have been returned, PickBlockToWrite returns
#	($firstBlock - 1).
#
sub InitBlockMap {
	($firstBlock, $lastBlock) = @_;
	my($i, $ul);
	use integer;

	Log("Initializing block map...");

	undef $blockMap;
	$ul = ($lastBlock - $firstBlock) / 32;
	if (($lastBlock - $firstBlock + 1) % 32) {
		$blockMap[$ul] = ~( (1 << (($lastBlock - $firstBlock) % 32 + 1)) - 1);
	}

	for ($i = 0; $i <= $ul; $i++) {
		$availBlocks{$i} = 1;
	}
	Log("done\n");
}

sub PickBlockToWrite {
	
	# Pick a block, any block...
	my($block) = int(rand($lastBlock - $firstBlock + 1));
	use integer;

	# Calculate the map entry for this block, and determine whether or not it has
	# already been written.
	#
	my($mapEntry) = $block / 32;

	if (defined($blockMap[$mapEntry]) && ($blockMap[$mapEntry] & (1 << ($block % 32)))) {

		# Picked an already written block.  Search the block of blocks that the
		# chosen block is in, and return the first unwritten one we find.
		#
		my($bbMap) = $blockMap[$mapEntry];
		if ($bbMap == -1) {

			# That block is completely written.  So get the next candidate block of
			# blocks from the list of available block blocks, and return the first
			# unwritten block from that block.
			#
			if (! %availBlocks) {
				# That's it! No more unwritten blocks to choose from. We return $firstBlock - 1.
				#
				return -1;
			}
			($mapEntry) = %availBlocks;
			$bbMap = $blockMap[$mapEntry];
		}

		$block = 0;
		until (($bbMap & 1) == 0) {
			$bbMap >>= 1;
			$block++;
		}

		$block += ($mapEntry * 32);
	}

	# Found an unwritten block to write.
	#
	$block + $firstBlock;
}

sub MarkBlockWritten {
	my($b) = @_;
	use integer;

	$b -= $firstBlock;

	if (($blockMap[$b/32] |= (1 << ($b % 32))) == -1) {
		delete $availBlocks{$b / 32};
	}
}

sub IsBlockWritten {
	my($b) = @_;
	use integer;

	$b -= $firstBlock;
	defined($blockMap[$b/32]) && ($blockMap[$b/32] & (1 << ($b % 32)));
}

sub Usage {
	print <<EOF;
Usage: $scriptName [options] <dev>
\t-D:            print a running commentary on the action
\t-F:            Full speed - don't wait when writelog begins to fill
\t-R:            initialize with random accesses (default: sequential access)
\t-f<sector>:    initialize starting at <sector> (default: 0, or 1 if 0 is disk label)
\t-l<sector>:    initialize up to <sector> (default: last sector of the device)
\t-s<size>:      sectors per block, in 512 byte sectors (default: $DFLT_SectorsPerBlock)
\t-S<seed>:      random number generator seed (default is the current time)
EOF
	die "\n";
}

sub Log {
	$opt_D && printf @_;
}
