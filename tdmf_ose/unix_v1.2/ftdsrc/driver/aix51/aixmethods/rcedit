#!/bin/sh
#
# LICENSED MATERIALS / PROPERTY OF IBM
# %PRODUCTNAME% version %VERSION%
# (c) Copyright %COMPANYNAME%  %COPYRIGHTYEAR 2001%.  All Rights Reserved.
# The source code for this program is not published or otherwise
# divested of its trade secrets, irrespective of what has been
# deposited with the U.S. Copyright Office.
# US Government Users Restricted Rights - Use, duplication or
# disclosure restricted by GSA ADP Schedule Contract with %COMPANYNAME%
#
# insert system startup hook in /etc/rc
# usage is to prepare the driver prior
# to any filesystem activity, the driver
# should be up and running before the
# system accesses volumes under its control.

# also, insert an entry in /etc/services

# rc related files this script touches
rcdir=/etc
rcfil=rc
rcsv_template=rc.pre-%Q%
rcsv=${rcsv_template}.$$
rcsedtmp=/tmp/rcsedtmp.$$
cmd=`basename $0`

# services related files this script touches
svcdir=/etc
svcfil=services
svcsv_template=services.pre-%Q%
svcsv=${svcsv_template}.$$

# default rmd port number 
rmdfltport=575

# whether access is permitted
whoami=`id -u`
if [ "${whoami}" != "0" ]
then
	echo "$cmd: must be root";
	exit 1;
fi

copy_file()
{
    cp -p "$1" "$2"
	cp_result=$?
	if [ cp_result -ne 0 ]
    then
     echo "$cmd: Copying $1 to $2 failed.";
	  echo "$cmd: This error is most likely caused by directory permissions"
	  echo "$cmd: or being out of space on the filesystem assoicated with the"
	  echo "$cmd: /etc directory which is normally the root filesystem."
	  sync
	  exit 1
    fi

    if ! cmp -s "$1" "$2"
    then
	  echo "$cmd: Comparing $1 to $2 after copying failed."
	  echo "$cmd: This error is most likely caused by being out of space on"
	  echo "$cmd: the filesystem the /etc directory is associated with which"
	  echo "$cmd: is normally the root filesystem."
	  sync
	  exit 1
    fi
}

copy_file_no_exit()
{
    cp -pf "$1" "$2"
	cp_result=$?
	if [ cp_result -ne 0 ]
    then
     echo "$cmd: Copying $1 to $2 failed.";
	  echo "$cmd: This error is most likely caused by directory permissions"
	  echo "$cmd: or being out of space on the filesystem assoicated with the"
	  echo "$cmd: /etc directory which is normally the root filesystem."
	  sync
	  return 1
    fi

    if ! cmp -s "$1" "$2"
    then
	  echo "$cmd: Comparing $1 to $2 after copying failed."
	  echo "$cmd: This error is most likely caused by being out of space on"
	  echo "$cmd: the filesystem the /etc directory is associated with which"
	  echo "$cmd: is normally the root filesystem."
	  sync
	  return 1
    fi

    return 0
}

check_space_for_2_copies()
{
    cp -p "$1" "$1.dtctemp1"
	cp_result=$?
	if [ cp_result -eq 0 ]
	then
	  cp -p "$1" "$1.dtctemp2"
	  cp_result=$?
	fi
	rm -f "$1.dtctemp1" 2> /dev/null
	rm -f "$1.dtctemp2" 2> /dev/null
	if [ cp_result -ne 0 ]
    then
	  echo "$cmd: Insufficient room to edit $1."
	  echo "$cmd: Please free at least twice the size of $1 on its associated filesystem."
	  sync
	  exit 1
    fi
}

unedit=0;
while getopts u o
do
        case ${o} in
                u)      unedit=1;;
                ?)      Usg; exit 2;;
        esac
done

# our contribution to the rc file:

#> ***************
#> *** 41,60 ****
#> --- 41,65 ----
#>  cfgvg
  
#>  # Activate all paging spaces in automatic list
#>  # (those listed in /etc/swapspaces)
#>  dspmsg rc.cat 3 ' Activating all paging spaces \n'
#>  swapon -a
#>  
#>+  
#>+ # @@@ %CAPQ% DRIVER START RC + @@@
#>+ # Perform %Q% driver start
#>+ <programs to run>
#>+ # @@@ %CAPQ% DRIVER START RC - @@@
#>+ 
#>  # Configure all dump devices
#>  sysdumpdev -q
#>   

# our contribution to the services file
#> ^in.%Q% %{rmdfltport}/tcp

# WR PROD5794: verifications added before and after modifying rc and services files
# to avoid situations where these files can be corrupted or zeroed out


# ================== UNINSTALLING ==================
# undo our changes
if [ ${unedit} -eq 1 ]
then
  exit_code=0  # Assume all is OK

  # ------- /etc rootvg migration and failover related files
  echo "Removing rootvg failover files if they exist..."
  rm -f /etc/SFTKdtc_call_mktcpip_at_boot 1> /dev/null 2>&1
  rm -f /etc/SFTKdtc_rootvg_failover_network_parms.txt 1> /dev/null 2>&1
  rm -f /etc/SFTKdtc_AIX_failover_boot_network_reconfig.sh 1> /dev/null 2>&1
  rm -f /etc/rc.tcpip.preSFTKdtc 1> /dev/null 2>&1
  rm -f /etc/rc.tcpip.postSFTKdtc 1> /dev/null 2>&1

  # Check if the current rc.tcpip has been modified by us; if so, restore the original
  grep SFTKdtc_AIX_failover_boot_network_reconfig /etc/rc.tcpip 1> /dev/null 2>&1
  result=$?
  if [ $result -eq 0 ]
  then
    # The current rc.tcpip is the one we have modified; we must restore the original one
    # If an error occurs while restoring, we keep the modified file, since it will not do any harm
    # now that the flag /etc/SFTKdtc_call_mktcpip_at_boot has been removed.
    # NOTE: we do not simply copy rc.tcpip.preSFTKdtc over the file in case the active rc.tcpip has been
    #       modified for something else.
    copy_file_no_exit "/etc/rc.tcpip" "/etc/rc.tcpip.postSFTKdtc"
    result=$?
    if [ $result -eq 0 ]
    then
        # Copy successful, remove current rc.tcpip that we have just backed up
        rm -f /etc/rc.tcpip
        # Remove the lines we have inserted in the file for failover boot script call and save into new rc.tcpip  
        sed -e '/@@@ CALL TO SFTKdtc FAILOVER NETWORK RECONFIGURATION SCRIPT + @@@/,/@@@ CALL TO SFTKdtc FAILOVER NETWORK RECONFIGURATION SCRIPT - @@@/d' \
        /etc/rc.tcpip.postSFTKdtc > /etc/rc.tcpip;

        # Check the resulting rc.tcpip file
        numrctcpiplines=`wc -l /etc/rc.tcpip | awk {'print $1'}`
        if [ $numrctcpiplines -eq 0 ] 
        then
          # The rc.tcpip file has not been properly saved. Restore the modified file.
	      rm -f /etc/rc.tcpip 1> /dev/null 2>&1
	      mv /etc/rc.tcpip.postSFTKdtc /etc/rc.tcpip
          echo "$cmd: undoing /etc/rc.tcpip changes failed (filesystem full?); keeping the current /etc/rc.tcpip file."
          echo "$cmd: please check if the filesystem is full and manually edit the file to remove the paragraph delimited by CALL TO SFTKdtc FAILOVER NETWORK RECONFIGURATION SCRIPT lines."
	      echo "$cmd: proceeding with uninstallation of other items..."
	      sleep 10
        else
          # Success
          echo "$cmd: call to SFKTdtc failover network reconfiguration script successfully removed from rc.tcpip";
          # Cleanup backup file
          rm -f /etc/rc.tcpip.postSFTKdtc
	    fi
    fi
  fi
  # Whatever manipulation has been done on rc.tcpip, make sure the final script is executable
  chmod 774 /etc/rc.tcpip

  # ------- rc file -------
  # First make sure we are not copying from a zeroed out rc file
  continue_rc_uninstall=1
  numrclines=`wc -l ${rcdir}/${rcfil} | awk {'print $1'}`
  if [ $numrclines -eq 0 ] 
  then
    exit_code=1;
    echo "$cmd: WARNING: ${rcdir}/${rcfil} seems to have been previously zeroed out."
    echo "$cmd: Looking for the most recent pre-dtc ${rcfil} backup file... "
	pre_dtc_rc="no_rc_pre_dtc_file"
	for pre_dtc_rc in `ls -tr ${rcdir} | grep ${rcsv_template} | /bin/awk '{print $1}' 2>/dev/null`
    do
	   echo " $pre_dtc_rc\c" 
	done
	if [ $pre_dtc_rc != "no_rc_pre_dtc_file" ]
	then
      numbklines=`wc -l ${rcdir}/${pre_dtc_rc} | awk {'print $1'}`
      if [ $numbklines -eq 0 ] 
      then
	    echo "\n$cmd: backup file found (${rcdir}/${pre_dtc_rc}) is not valid. ${rcdir}/${rcfil} needs to be restored from another backup."
	    echo "$cmd: Proceeding with uninstallation of other items..."
	    continue_rc_uninstall=0
	    sleep 10
	  else
	    echo "\n$cmd: Restoring ${rcdir}/${rcfil} from backup file $pre_dtc_rc."
	    mv ${rcdir}/${rcfil} ${rcdir}/${rcfil}.found_bad.$$
	    copy_file ${rcdir}/${pre_dtc_rc} ${rcdir}/${rcfil}
	    echo "$cmd: Please verify that the restored file contains all the latest ${rcfil} updates."
	    echo "$cmd: Continuing uninstallation..."
	    # We don't expect to have anything to uninstall in the restored file, but previous errors
	    # could have left the driver hook which would have ended up in the pre-dtc backup file;
	    # so we continue the rc uninstall part.
	    continue_rc_uninstall=1
	    sleep 10
	  fi
	else
	  echo "$cmd: No ${rcsv_template} backup file found. ${rcdir}/${rcfil} needs to be restored from another backup."
	  echo "$cmd: Proceeding with uninstallation of other items..."
	  continue_rc_uninstall=0
	  sleep 10
	fi
  fi

  if [ $continue_rc_uninstall -eq 1 ]
  then 
    # ok to proceed
    # Note: copy_file verifies the copy result; we can rely on the copy
    copy_file "${rcdir}/${rcfil}" "${rcdir}/${rcsv}"

    # Remove the driver start paragraph from the rc file  
    sed -e '/@@@ %CAPQ% DRIVER START RC + @@@/,/@@@ %CAPQ% DRIVER START RC - @@@/d' \
    ${rcdir}/${rcsv} > ${rcdir}/${rcfil};

    # Check the resulting rc file
    numrclines=`wc -l ${rcdir}/${rcfil} | awk {'print $1'}`
    if [ $numrclines -eq 0 ] 
    then
      exit_code=1;
      # The rc file has not been properly saved. Restore the file.
	  rm -f ${rcdir}/${rcfil} 1> /dev/null 2>&1
	  mv ${rcdir}/${rcsv} ${rcdir}/${rcfil}
      echo "$cmd: undoing ${rcdir}/${rcfil} changes failed (filesystem full?); keeping the current ${rcdir}/${rcfil} file."
      echo "$cmd: please check if the filesystem is full and manually edit the file to remove the paragraph delimited by %CAPQ% DRIVER START RC lines."
	  echo "$cmd: proceeding with uninstallation of other items..."
	  sleep 10
    else
      # Success
      echo "$cmd: driver start hook deinstalled";
      # Clean up old backup files
      rm -f ${rcdir}/${rcsv_template}.*
	fi
  fi #... of: if [ $continue_rc_uninstall -eq 1 ]
  sync

  # ------- /usr/sbin/shutdown ODM hook -------
  odmdelete -o PdAt -q uniquetype="%Q%_class/%Q%_subclass/%Q%"
  echo "$cmd: driver stop hook deinstalled";  

  # ------- services file -------
  # WR PROD5357, 5794, 1463:
  # First make sure we are not copying from a zeroed out services file
  numsvclines=`wc -l "${svcdir}/${svcfil}" | awk {'print $1'}`
  if [ $numsvclines -eq 0 ] 
  then
    echo "$cmd: WARNING: ${svcdir}/${svcfil} seems to have been previously zeroed out."
    echo "$cmd: Looking for the most recent pre-dtc ${svcfil} backup file... "
	pre_dtc_svc="no_svc_pre_dtc_file"
	for pre_dtc_svc in `ls -tr ${svcdir} | grep ${svcsv_template} | /bin/awk '{print $1}' 2>/dev/null`
    do
	   echo " $pre_dtc_svc\c" 
	done
	if [ $pre_dtc_svc != "no_svc_pre_dtc_file" ]
	then
	  # Check that the backup file is valid
      numbklines=`wc -l ${svcdir}/${pre_dtc_svc} | awk {'print $1'}`
      if [ $numbklines -eq 0 ] 
      then
	    echo "\n$cmd: backup file found (${svcdir}/${pre_dtc_svc}) is not valid. ${svcdir}/${svcfil} needs to be restored from another backup."
	    sleep 10
		sync
        exit 1;  # No in.dtc entry to remove in this case here; signal abnormal conditions
	  fi
	  echo "\n$cmd: Restoring ${svcdir}/${svcfil} from backup file $pre_dtc_svc."
	  mv ${svcdir}/${svcfil} ${svcdir}/${svcfil}.found_bad.$$
	  mv ${svcdir}/${pre_dtc_svc} ${svcdir}/${svcfil}
	  echo "$cmd: Please verify that the restored file contains all the latest ${svcfil} updates."
	  # We don't expect to have anything to uninstall in the restored file. Cleanup any old backups and terminate.
      rm -f ${svcdir}/${svcsv_template}.* 1> /dev/null 2>&1
      sync
	else
	  echo "$cmd: No ${svcsv_template} backup file found. ${svcdir}/${svcfil} needs to be restored from another backup."
	fi
	sleep 10
	sync
    exit 1;  # No in.dtc entry to remove in this case here; signal abnormal conditions anyway
  fi
  # ok to proceed
  # There must be room for at least 2 copies of the services file:
  #   one copy for "${svcdir}/${svcsv}"
  #   and another for ${svcdir}/${svcfil}.tmp (for sed output)
  check_space_for_2_copies "${svcdir}/${svcfil}"
  # Note: copy_file verifies the copy result; we can rely on the copy
  copy_file "${svcdir}/${svcfil}" "${svcdir}/${svcsv}"

  # Remove our master daemon entry from the file 
  sed -e '/^in.%Q%/d' ${svcdir}/${svcsv} > ${svcdir}/${svcfil}.tmp;

  # Verify sed's output
  expectedlines=`expr $numsvclines - 1`  
  numsvctmplines=`wc -l ${svcdir}/${svcfil}.tmp | awk {'print $1'}`

  if [ $numsvctmplines -eq $expectedlines ] 
  then
    mv ${svcdir}/${svcfil}.tmp ${svcdir}/${svcfil}
  else
    echo "$cmd: undoing changes to ${svcdir}/${svcfil} has failed; please verify that the filesystem is not full."
    echo "$cmd: expected number of lines in intermediary work file: $expectedlines; actual: $numsvctmplines."
    echo "$cmd: preserving current ${svcdir}/${svcfil}"
	echo "$cmd: please verify if the filesystem is full and manually remove the in.%Q% entry from ${svcdir}/${svcfil}"
    rm -f ${svcdir}/${svcfil}.tmp 1> /dev/null 2>&1
	rm -f ${svcdir}/${svcsv} 1> /dev/null 2>&1
	sleep 10
	sync
    exit 1;
  fi
  # Success; clean up
  rm -f ${svcdir}/${svcsv_template}.*
  sync

  exit $exit_code;   # Must return the exit_code as set by uninstall of /etc/rc (first uninstall part)
fi

# ================== INSTALLING ==================

# ------- rc file -------
# Check whether already done
startinstalled=0;
cat ${rcdir}/${rcfil} |\
sed -n -e '/@@@ %CAPQ% DRIVER START RC + @@@/,/@@@ %CAPQ% DRIVER START RC - @@@/p' |\
egrep "(^/etc/%Q%/init.d/%Q%-startdriver)"
if [ $? -eq 0 ]
then
	echo "$cmd: driver start hook already installed";
	startinstalled=1;
else
	echo "$cmd: driver start hook not installed";
	echo "$cmd: installing driver start hook";
fi

if [ ${startinstalled} -eq 0 ]
then

  # make a backup copy of /etc/rc
  # Take note of the original length of the rc file and make sure we are not copying from a corrupted file
  numrclines=`wc -l ${rcdir}/${rcfil} | awk {'print $1'}`
  if [ $numrclines -eq 0 ] 
  then
    echo "$cmd: WARNING: cannot install; ${rcdir}/${rcfil} seems to have been zeroed out prior to installation of the product."
	sleep 10
    exit 1
  fi
  # ok to backup
  # Note: copy_file verifies the copy result; we can rely on the copy
  copy_file "${rcdir}/${rcfil}" "${rcdir}/${rcsv}"

  # chk for the context to be modified 
  # insert the hook right after swap is configured.
  lnum=`cat ${rcdir}/${rcsv} | sed -n -e '/^swapon/='`
  if [ "${lnum}" = "" ]
  then
	echo "$cmd: Cannot determine the placement of the driver hook in"
	echo "$cmd: the file $rcdir/$rcfil.  Please call technical support about."
	echo "$cmd: the failure of %Q%-rcedit script."
	sleep 10
	exit 1;
  fi

  # line preceding this address
  lnum=`expr ${lnum} + 1`
  echo "$cmd: inserting driver start hook at line ${lnum} of ${rcdir}/${rcfil}"
  
  # make a sed command
  # WARNING: if you modify what is put in the sed cmd file or the final rc file, you must check that the
  #          number of lines matches those in the verification done after (PROD1463)
  sedcmdlines=6
  linestoinsert=4
  cat > ${rcsedtmp} << EOSEDCMD
${lnum} a\\
# @@@ %CAPQ% DRIVER START RC + @@@\\
# Start %Q% driver and services\\
/etc/%Q%/init.d/%Q%-startdriver\\
# @@@ %CAPQ% DRIVER START RC - @@@

EOSEDCMD

  # PROD1463: verify that we successfully created the sed cmd file before attempting to apply it
  # IMPORTANT: if you change the contents of the sed cmd file, you must adjust the number of lines
  # in the verification that follows:
  numsedlines=`wc -l ${rcsedtmp} | awk {'print $1'}`
  if [ $numsedlines -lt $sedcmdlines ] 
  then
    echo "$cmd: ERROR: preparing sed command file ${rcsedtmp} for editing ${rcdir}/${rcfil} failed."
    echo "$cmd: expected number of lines in ${rcsedtmp}: $sedcmdlines; actual: $numsedlines."
    echo "$cmd: this error is most likely caused by /tmp being full."
    rm -f ${rcsedtmp} 1> /dev/null 2>&1
    rm -f ${rcdir}/${rcsv} 1> /dev/null 2>&1
	sleep 10
    exit 1
  fi

  # apply the patch
  # WR PROD5794: make sure we are not corrupting nor zeroing the rc file due to some sed error
  numrclines=`wc -l ${rcdir}/${rcfil} | awk {'print $1'}`
  cat ${rcdir}/${rcsv} | sed -f ${rcsedtmp} > ${rcdir}/${rcfil}

  newrclines=`wc -l ${rcdir}/${rcfil} | awk {'print $1'}`
  expectedlines=`expr ${numrclines} + ${linestoinsert}`
  if [ $newrclines -ne $expectedlines ] 
  then
    echo "$cmd: WARNING: an error occured while trying to insert driver start hook in ${rcdir}/${rcfil}."
    echo "$cmd: this error is most likely caused by /tmp or the filesystem associated with ${rcdir} being full."
    echo "$cmd: original number of lines in ${rcdir}/${rcfil}: $numrclines; new number of lines: $newrclines; expected: $expectedlines"
    echo "$cmd: preserving original ${rcdir}/${rcfil}."
    rm -f ${rcdir}/${rcfil} 1> /dev/null 2>&1
	mv ${rcdir}/${rcsv} ${rcdir}/${rcfil}
	sleep 10
	sync
    exit 1
  fi

  # clean up
  rm -f ${rcsedtmp}

  # all might be well
  echo "";
  echo "$cmd: advice:";
  echo "";
  echo "    please inspect ${rcdir}/${rcfil}.";
  echo "";
  echo "    the following lines have been added";
  echo "    between configuration of the system";
  echo "    swap devices, and before filesystem";
  echo "    checks:";
  echo "";
  echo "# @@@ %CAPQ% DRIVER START RC + @@@";
  echo "# Perform %Q% driver start";
  echo "/etc/%Q%/init.d/%Q%-startdriver"
  echo "# @@@ %Q% DRIVER START RC - @@@";
  echo "";

fi # ... of: if [ ${startinstalled} -eq 0 ]

# ------- shutdown hook -------
# Install our shutdown hook if not already installed
odmget -q uniquetype="%Q%_class/%Q%_subclass/%Q%" PdAt | grep %Q% 1> /dev/null 2>&1
if [ $? -eq 0 ]
then
	echo "$cmd: driver stop hook already installed";
else
	echo "$cmd: driver stop hook not installed";
	echo "$cmd: installing driver stop hook";

        # The usage of the shutdown_notify hook can be seen within the /usr/sbin/shutdown script.
        # See also:
        #  http://publib.boulder.ibm.com/infocenter/aix/v6r1/index.jsp?topic=/com.ibm.aix.genprogc/doc/genprogc/odm.htm
        #  http://publib16.boulder.ibm.com/doc_link/en_US/a_doc_lib/libs/ktechrf2/Predefined_Attributes.htm
        #  WR PROD00003602

	cat <<EOF | odmadd
PdAt:
        uniquetype = "%Q%_class/%Q%_subclass/%Q%"
        attribute = "shutdown_notify"
        deflt = "/etc/%Q%/init.d/%Q%-stopdriver"
        values = ""
        type = "R"
        rep = "s"
EOF

fi

# ------- services file -------

# check if already done
cat ${svcdir}/${svcfil} | \
grep '^in.%Q%' 1> /dev/null 2>&1
if [ $? -eq 0 ]
then
	echo "$cmd: ${svcdir}/${svcfil} entry installed";
	exit 0;
else
	echo "$cmd: ${svcdir}/${svcfil} entry not installed";
	echo "$cmd: installing ${svcdir}/${svcfil} entry";
fi

# install services file entry

# make a backup copy of services file but first check that the original is valid
numsvclines=`wc -l "${svcdir}/${svcfil}" | awk {'print $1'}`
if [ $numsvclines -eq 0 ] 
then
  echo "$cmd: ERROR: ${svcdir}/${svcfil} seems to have been previously zeroed out. The file must be restored."
  echo "$cmd: undoing changes to ${rcdir}/${rcfil}."
  rm -f ${rcdir}/${rcfil} 1> /dev/null 2>&1 
  mv "${rcdir}/${rcsv}" "${rcdir}/${rcfil}"
  echo "$cmd: uninstalling driver stop hook."
  odmdelete -o PdAt -q uniquetype="%Q%_class/%Q%_subclass/%Q%"
  sleep 10
  sync
  exit 1;
fi
# ok to proceed
# Note: copy_file verifies the copy result; we can rely on the copy
copy_file "${svcdir}/${svcfil}" "${svcdir}/${svcsv}"

# install entry
echo "in.%Q%\t\t${rmdfltport}/tcp" >> ${svcdir}/${svcfil};

# Verify length of output file
expectedlines=`expr ${numsvclines} + 1`
numsvclines=`wc -l "${svcdir}/${svcfil}" | awk {'print $1'}`
if [ $numsvclines -ne $expectedlines ] 
then
  echo "$cmd: ERROR: insertion of in.%Q% entry in ${svcdir}/${svcfil} failed."
  echo "$cmd: expected number of lines after insertion: $expectedlines; actual: $numsvclines."
  echo "$cmd: restoring original ${svcdir}/${svcfil}."
  rm -f ${svcdir}/${svcfil} 1> /dev/null 2>&1
  mv ${svcdir}/${svcsv} ${svcdir}/${svcfil}
  echo "$cmd: undoing changes to ${rcdir}/${rcfil}."
  rm -f ${rcdir}/${rcfil} 1> /dev/null 2>&1 
  mv "${rcdir}/${rcsv}" "${rcdir}/${rcfil}"
  echo "$cmd: uninstalling driver stop hook."
  odmdelete -o PdAt -q uniquetype="%Q%_class/%Q%_subclass/%Q%"
  sleep 10
  sync
  exit 1
fi

# all might be well
echo "";
echo "$cmd: advice:";
echo "";
echo "    please inspect ${svcdir}/${svcfil}.";
echo "";
echo "    the following line has been added:";
echo "";
echo "    in.%Q%\t\t${rmdfltport}/tcp";
echo "";

# all done
sync
exit 0;
