#!/bin/ksh
LANG=C
export LANG
######################################################################
# Program:
# --------
# debugcapture (%VERSION%) for AIX
#
# LICENSED MATERIALS / PROPERTY OF IBM
# %PRODUCTNAME% version %VERSION%
# (c) Copyright %COMPANYNAME%  %COPYRIGHTYEAR 2001%.  All Rights Reserved.
# The source code for this program is not published or otherwise
# divested of its trade secrets, irrespective of what has been
# deposited with the U.S. Copyright Office.
# US Government Users Restricted Rights - Use, duplication or
# disclosure restricted by GSA ADP Schedule Contract with %COMPANYNAME%
#
#
# $RCSfile: debugcapture.sh.AIX,v $
# $Revision: 1.44 $
# $Date: 2014/10/15 20:10:05 $
#
# Usage:
# ------
#       nodename1# debugcapture
#       nodename1# debugcapture /tmp/work_dir
# ------------
#
# This program collects system and Replicator/TDMF/TDMF-IP information.
#

E="echo"

id="/usr/bin/id"
if [ `${id} -u` != 0 ]; then
    ${E} "Error: `${id}`
  One must be root." >&2
    exit 1
fi

if [ -z "$work_dir" ]
then
	work_dir="/var/tmp"
	if [ -z "$1" ]
	then
		${E} "
The working directory is \"${work_dir}\".
You may specify a directory for workspace and final output.
abort this script (ctrl-c) and specify a different directory if desired
	$0 work_dir
"
	/bin/sleep 5
	else
		work_dir="$1"
	fi
fi

#
# Define "check_executable" and "verify_executable".
#
check_executable() {
        if [ ! -x "${1}" ]; then
                ${E} "Warning: unable to find an executable \"${1}\"." >&2
        fi
}

verify_executable() {
        if [ ! -x "${1}" ]; then
                ${E} "Error: unable to find an executable \"${1}\"." >&2
                exit 1
        fi
}

#
# Verify executables.
#
# These are required:
awk="/bin/awk"
cat="/bin/cat"
egrep="/usr/bin/egrep"
grep="/bin/grep"
id="/bin/id"
uname="/bin/uname"
date="/usr/bin/date"
swverify="/usr/bin/lppchk"
strings="/usr/bin/strings"
sum="/usr/bin/cksum"
test="/usr/bin/test"

for command in ${awk} ${cat} ${id} ${egrep} ${grep} ${uname} ${date} ; do
        verify_executable ${command}
done

# Check the suitability of "${work_dir}".
if   [ ! -d "${work_dir}" ]; then
        ${E} "Error: \"${work_dir}\" is not a directory." >&2
        ${E} "Error: The variable \"work_dir\" is not set correctly." >&2
        exit 1
else
        ${E} "The working directory is \"${work_dir}\"."
        ${E} ""
fi

#
# Display an informational message.
#
######################################################################
${E} "
This program will collect system and Softek TDMF/Replicator diagnostic
information.
"
######################################################################

#
# Set up command variables to be absolute pathnames.
#
# Required commands.
#
basename="/bin/basename"
chmod="/bin/chmod"
compress="/bin/compress"
cp="/bin/cp"
cp_r="/bin/cp -f -R -p"
dirname="/bin/dirname"
ls="/bin/ls"
mkdir="/bin/mkdir"
rm="/bin/rm"
sed="/bin/sed"
tar="/bin/tar"
touch="/bin/touch"
req_commands="
        ${basename}
        ${chmod}
        ${compress}
        ${cp}
        ${dirname}
        ${ls}
        ${mkdir}
        ${rm}
        ${sed}
        ${tar}
        ${touch}"
#
# Optional commands for system data generation.
#
arpinfo="/usr/sbin/arp -an /dev/kmem"
bootinfo="/usr/sbin/bootinfo"
cpio=/usr/bin/cpio
crash="/usr/sbin/crash"
cut=/usr/bin/cut
df="/bin/df"
filetype="/usr/bin/file"
find=/usr/bin/find
ifconfig="/etc/ifconfig"
instfix="/usr/sbin/instfix"
iostat=/usr/bin/iostat
ipcs="/bin/ipcs"
lsattr="/usr/sbin/lsattr"
lscfg="/usr/sbin/lscfg"
lsdev="/usr/sbin/lsdev"
lslpp="/usr/bin/lslpp"
lssrc=/usr/bin/lssrc
mount="/usr/sbin/mount"
netstat="/bin/netstat"
no="/usr/sbin/no"
odmget=/usr/bin/odmget
oslevel="/usr/bin/oslevel"
ping=/etc/ping
prtconf=/usr/sbin/prtconf
ps="/bin/ps"
sar="/usr/sbin/sar"
sort="/usr/bin/sort"
svmon=/usr/bin/svmon
swap="/usr/sbin/lsps"
tail="/bin/tail"
tr="/usr/bin/tr"
true="/bin/true"
uptime=/usr/bin/uptime
vmstat=/usr/bin/vmstat
who=/usr/bin/who
xargs=/usr/bin/xargs

command00="${date}"
command01="${cat} /etc/motd"
command02="${uname} -aL"
command03="${oslevel} -r"
command04="${df} -k"
command05="${mount}"
command06="${ifconfig} -a"
command07="${iostat}"
command08="${vmstat}"
command09="${swap} -s"
command10="${swap} -a"
command11="${svmon}"
command12="${arpinfo}"
command13="${lslpp} -l \"dtc.rte*\" "
command14="${lslpp} -L all"
command15="${swverify} -c \"dtc.rte*\" "
command16="${swverify} -v \"dtc.rte*\" "
command17="/bin/echo p | ${crash}"
command18="${ipcs} -a"
#
# Note: The commands are executed in the order
#       of top to bottom to generate system data.
#
data_commands='
        ${command00}
        ${command01}
        ${command02}
        ${command03}
        ${command04}
        ${command05}
        ${command06}
        ${command07}
        ${command18}
        ${command19}
        ${command10}
        ${command11}
        ${command12}
        ${command13}
        ${command14}
        ${command15}
        ${command16}
        ${command17}
        ${command18}
        '

#
# Verify the executability of ${req_commands}.
#
# These are required:
for command in ${req_commands}; do
        verify_executable ${command}
done

#
# Set up destination directory and file names.
#
archive=`${uname} -n`.`${date} +\%Y\%m\%d-\%H\%M`

dest_dir="${work_dir}/${archive}"

data_file="${dest_dir}/misc_info.txt"

#
# Set up destination directory.
#
(
cd ${work_dir}
${rm} -rf ${archive} ${archive}.tar ${archive}.tar.Z ${archive}.tar.Z.uu
)

${mkdir} ${dest_dir}; ${chmod} 700 ${dest_dir}

#
# Define cleanup function and install interrupt handler
#
cleanup() {
(
cd ${work_dir}
${rm} -rf ${archive} ${archive}.tar ${archive}.tar.Z ${archive}.tar.Z.uu
)
exit 1
}

trap cleanup 1 2 3 4 10 15

######################################
# Generic system investigation, not Softek specific
######################################

${E} "Capture running processes"
${E} "++++++++++++++++++++[ ${who} -b ]:" > ${dest_dir}/ps-output.txt
${who} -b  >> ${dest_dir}/ps-output.txt
${E} "++++++++++++++++++++[ ${uptime} ]:" >> ${dest_dir}/ps-output.txt
${uptime} >> ${dest_dir}/ps-output.txt
${E} "++++++++++++++++++++[ ${ps} -el ]:" >> ${dest_dir}/ps-output.txt
${ps} -el >> ${dest_dir}/ps-output.txt
${E} "++++++++++++++++++++[ ${ps} -ef ]:" >> ${dest_dir}/ps-output.txt
${ps} -ef >> ${dest_dir}/ps-output.txt
${E} "++++++++++++++++++++[ ${instfix} -i ]:" >> ${dest_dir}/instfix-output.txt
${instfix} -i >> ${dest_dir}/instfix-output.txt

${lssrc} -a > ${dest_dir}/lssrc-a.txt

if [ -x ${sar} ]
then
  ${E} "Capture system activity report"
  ${E} "++++++++++++++++++++[ ${sar} -du 5 ]:" > ${dest_dir}/sar-output.txt
  ${sar} -du 5 >> ${dest_dir}/sar-output.txt
fi

${ls} -laRF /dev >${dest_dir}/ls--dev.txt
${odmget} CuAt >${dest_dir}/odmget-CuAt.txt

# Network items aren't needed for TDMF, but pre-install survey
# captures some data here anyway.

${no} -a > ${dest_dir}/no-a.txt

${E} "Capture all of the netstat arguments individually"
for netstats in s rn pn dn i in m an v s
do
    ${E} "++++++++++++++++++++[ ${netstat} -${netstats} ] "
	${netstat} -${netstats}
done > ${dest_dir}/netstat.txt 2>&1

${E} Capture all options from uname
for unames in a x F f l L m M n p r s u v
do
  ${E} "++++++++++++++++++++[ ${uname} -${unames} ] "
  ${uname} -${unames}
done > ${dest_dir}/unames.txt 2>&1

${E} Capture hardware and bootinfo
(
  ${E} ${bootinfo}
  ${E} -b Returns the last boot device.
  ${bootinfo} -b
  ${E} -K running kernel 32 bit or 64 bit.
  ${bootinfo} -K
  ${E} -m Displays the machine model code.
  ${bootinfo} -m
  ${E} -p Displays the hardware platform type of the running machine. 
  ${bootinfo} -p
  ${E} -r Displays amount of real memory in kilobytes.
  ${bootinfo} -r
  ${E} -y 32 or 64 bit capable hardware
  ${bootinfo} -y
  ${E} -z 0:not MP-capable.  1:MP-capable.
  ${bootinfo} -z
) > ${dest_dir}/bootinfo.txt 2>&1

${E} Capture device database
${lsdev} -C > ${dest_dir}/lsdev-C.txt 2>&1

${E} "Capture some system and ethernet hardware information "
${lscfg} > ${dest_dir}/lscfg.txt 2>&1
${prtconf} > ${dest_dir}/prtconf.txt 2>&1

for Card in sys0 `${grep} "^en" ${dest_dir}/lsdev-C.txt|${cut} -d' ' -f1`
do
  ${E} +++++++ ${lsattr} -E -l ${Card}
  ${lsattr} -E -l ${Card}
done > ${dest_dir}/lsattr.txt 2>&1

# Generate the data file.
#
# Note: The use of "check_executable ${command}" will work when
#       "${command}" has the form "<command> <flags>".  This usage
#       could give somewhat misleading information in some cases,
#       for example, "/bin/echo p | crash".
#
${E} "Capture system data .\c"
${E} ' debugcapture (%VERSION%.%BUILDNUM%) for AIX
 $Date: 2014/10/15 20:10:05 $ ' > ${data_file}
for command in ${data_commands}; do
        eval execute="${command}"
        ${E} "++++++++++++++++++++[ ${execute} ]:" >> ${data_file} 
        result=`check_executable ${execute} 2>&1`
        if [ -z "${result}" ]; then
                eval ${execute} >> ${data_file} 2>&1
        else
                ${E} "${result}" >> ${data_file}
        fi
        ${E} "" >> ${data_file}
        ${E} ".\c" 
done
ulimit -a >> ${data_file}
        ${E} ""

# 	defragfs -q /var or /dev/dtc/dsk/lgN/dtcN or rdsk

lspv="/usr/sbin/lspv"
lsvg="/usr/sbin/lsvg"
lslv="/usr/sbin/lslv"
getlvcb=/usr/sbin/getlvcb

${E} "Capture volume group and volume definitions"
VOLFILE="${dest_dir}/volume_group_info.txt"
${E} "++++++++++ lspv" > ${VOLFILE}
${lspv} >> ${VOLFILE} 2>&1
${E} "++++++++++ lsvg -o" >> ${VOLFILE}
${lsvg} -o >> ${VOLFILE} 2>&1
${E} "++++++++++ lsvg" >> ${VOLFILE}
${lsvg} >> ${VOLFILE} 2>&1
VOLGRPS=`${lsvg}`
${E} "Volume Groups = ${VOLGRPS}" >> ${VOLFILE}
${E} "========================================" >> ${VOLFILE}
for VOLGRP in ${VOLGRPS}; do
    ${E} " " >> ${VOLFILE}
    ${E} "========================================" >> ${VOLFILE}
    ${E} "Volume Group = ${VOLGRP}" >> ${VOLFILE}
    ${E} "++++++++++" >> ${VOLFILE}
    ${E} "lsvg ${VOLGRP}" >> ${VOLFILE}
    ${lsvg} ${VOLGRP} >> ${VOLFILE} 2>&1
    ${E} "++++++++++" >> ${VOLFILE}
    ${E} "lsvg -l ${VOLGRP}" >> ${VOLFILE}
    ${lsvg} -l ${VOLGRP} >> ${VOLFILE} 2>&1
    ${E} "++++++++++" >> ${VOLFILE}
#    ${E} "lsvg -M ${VOLGRP}" >> ${VOLFILE}
#    ${lsvg} -M ${VOLGRP} >> ${VOLFILE} 2>&1
    LVOLS=`${lsvg} -l ${VOLGRP} 2>/dev/null | ${sed} -n '3,$p' | /bin/awk '{print $1}'`
    for LVOL in ${LVOLS}; do
        ${E} "----------" >> ${VOLFILE}
        ${E} "Volume Group:  ${VOLGRP}   Logical Volume:  ${LVOL}" >> ${VOLFILE}
        ${E} "-----" >> ${VOLFILE}
        ${E} "lslv ${LVOL}" >> ${VOLFILE}
        ${lslv} ${LVOL} >> ${VOLFILE}
        ${E} "-----" >> ${VOLFILE}
        ${E} "lslv -l ${LVOL}" >> ${VOLFILE}
        ${lslv} -l ${LVOL} >> ${VOLFILE}
        ${E} "-----" >> ${VOLFILE}
        ${E} "getlvcb -AT ${LVOL}" >> ${VOLFILE}
        ${getlvcb} -AT ${LVOL} >> ${VOLFILE}
        ${E} "-----" >> ${VOLFILE}
    done
done

# VxVM (vxfs) specific.
# This data is very large, and not normally useful for debug
#
#vxvm="/etc/vx"
#if [ -d "${vxvm}" ]
#then
#    ${E} "Capture VxVM files "
#    ${mkdir} -p ${dest_dir}/${vxvm}
#    ${cp_r} -p ${vxvm} ${dest_dir}/
#fi

vxdg="/usr/sbin/vxdg"
vxdisk="/usr/sbin/vxdisk"
vxinfo="/usr/sbin/vxinfo"
vxprint="/usr/sbin/vxprint"

if [ -x "${vxdg}" -a -x "${vxprint}" ]; then
    ${E} "Capture Veritas volume group and volume definitions"
    (
	${E} "++++++++++++++++++++[ ${vxdisk} list ]:" 
	${vxdisk} list 

	${E} "++++++++++++++++++++[ ${vxdg} list ]:" 
	${vxdg} list 

	for VXGroup in `${vxdg} -q list  |cut -d' ' -f1 `
	do
	  $E ++++++++++++++++++++ [ ${vxinfo} -g ${VXGroup} ]
	  ${vxinfo} -g ${VXGroup}
	done

	${E} "++++++++++++++++++++[ ${vxprint} ]:" 
	${vxprint} 
	) > ${dest_dir}/vxdata.txt  2>&1
fi

${E} Looking for HACMP Cluster status and logs

# Parse the HACMPlogs from odm.
${odmget} HACMPlogs > ${dest_dir}/odmget-HACMPlogs.txt 2>&1
files=`${odmget} HACMPlogs 2>/dev/null |
 ${egrep} name\|value 2>/dev/null |
   ${awk} '{
	FileName=$3
	gsub(/mmddyyyy/,"????????", FileName)
	getline Value
	split(Value,DirName)
	gsub("\"","",FileName)
	gsub("\"","",DirName[3])
	print DirName[3] "/" FileName "*"
   }' 2>/dev/null `
${test} -n "${files}" && ${ls} ${files} 2>/dev/null |
 ${cpio} -pdum ${dest_dir}/ 2>/dev/null

# get known file locations, in case odm won't work.
files="/tmp/hacmp.*
  /tmp/cspoc.*
  /var/hacmp/log/*
  /tmp/clstrmgr.*
  /usr/es/adm/cluster.*
  /usr/es/sbin/cluster/events/utils/*activate*
  "
${ls} ${files} 2>/dev/null | ${cpio} -pdm ${dest_dir}/ 2>/dev/null


clbin=/usr/es/sbin/cluster
test -x ${clbin}/clstat && for clcmd in \
 "${clbin}/clstat -ao" \
 "${clbin}/utilities/clRGinfo -v -t -p " \
 ${clbin}/utilities/cldisp \
 ${clbin}/utilities/cldump \
 ${clbin}/utilities/clfindres \
 ${clbin}/utilities/cllsif \
 ${clbin}/utilities/clshowres \
 "${clbin}/utilities/clshowsrv  -a -v " \
 ${clbin}/utilities/cltopinfo
do
	${E} "++++++++++++++++++++[ ${clcmd} ]:" 
	$clcmd 
done > ${dest_dir}/cluster.txt 2>&1

${E} "Capture current system configuration files"
${mkdir} ${dest_dir}/etc
${cp} -p /etc/* ${dest_dir}/etc 2> /dev/null
${find} /etc/rc* | ${cpio} -pdum ${dest_dir} 2>/dev/null

# Don't keep any password file copy
${rm} ${dest_dir}/etc/*passwd* 2> /dev/null

#
# get the system error log
# 
${E} "Capture system error log report"
/bin/errpt -a > ${dest_dir}/errpt.txt
alog=/usr/bin/alog
for logtypes in `$alog -L`
do
	${E} "+++++++++++++++ alog -o -t $logtypes"
	$alog -o -t $logtypes
done > ${dest_dir}/alog.txt 2>&1

if [ -f /etc/syslog.conf ]
then
  ${E} Copying syslog files
  files=`${awk} '$1 !~ /^#/{ sub("\\\*","",$NF); sub("^-","",$NF); print $NF }' /etc/syslog.conf`

  test -n "${files}" && files=`echo ${files} |
	${xargs} ${filetype} |${grep} text|${cut} -d: -f1`
  test -n "${files}" && ${ls} ${files} | ${cpio} -pdum ${dest_dir}/

fi

${cp} -p /smit.log ${dest_dir}/ 2> /dev/null

  ${E} "######################################################################
# start of dtc specific tasks
######################################################################"

PKGNM="SFTKdtc"
SWNM="dtc.rte"

dtcbindir=/usr/dtc/bin
dtccfgbase=/etc/dtc
dtccfgdir=${dtccfgbase}/lib
dtcvardir=/var/dtc
dtcdrvdir=/usr/lib/drivers


dtcdrv=$dtcdrvdir/dtc

if [ -d ${dtcvardir} ]
then
	mkdir -p ${dest_dir}/${dtcvardir} &&
	    ${cp_r} -f ${dtcvardir}/* ${dest_dir}/${dtcvardir} 2> /dev/null
fi

${test} -d ${dest_dir}/tmp || ${mkdir} ${dest_dir}/tmp 
	${cp} -f -p /tmp/in.???.log ${dest_dir}/tmp 2> /dev/null

# do more only if we are installed.

if [ -x ${dtcbindir}/dtcinfo ]
then

  ${E} "Capture directory listings"

  ${ls} -laRF  ${dtccfgbase} >${dest_dir}/ls--dtccfgdir.txt
  ${ls} -laRF  ${dtcvardir} >${dest_dir}/ls--dtcvardir.txt
  ${ls} -laRF  ${dtcdrvdir} >${dest_dir}/ls--dtcdrvdir.txt
  
  ${E} "Capture $PKGNM files"
  mkdir -p ${dest_dir}/${dtccfgbase} &&
    ${cp_r} -f ${dtccfgbase}/* ${dest_dir}/${dtccfgbase}/ 2> /dev/null
  mkdir -p ${dest_dir}/${dtcdrvdir} &&
    ${cp_r} -f ${dtcdrvdir}/dtc* ${dest_dir}/${dtcdrvdir} 2> /dev/null
  
  ${E} "Obtaining Mobility driver configuration and status files"
  ${test} -f /usr/lib/methods/dtc.get &&
      /usr/lib/methods/dtc.get > ${dest_dir}/dtc.get.txt
  
  ${E} "Verifying dtc binaries"
  ${E} dtcinfo -v >  ${dest_dir}/bin-info-${PKGNM}.txt
  ${dtcbindir}/dtcinfo -v >> ${dest_dir}/bin-info-${PKGNM}.txt
  for file in $dtcbindir/* $dtcdrv 
   do
     if [ -f "${file}" ]
     then
       ${E} "----------" 
       ${ls} -laF ${file} 
       ${filetype} ${file} 
       ${sum} ${file} 
       ${strings} ${file} | ${grep} Version 
     fi
  done >> ${dest_dir}/bin-info-${PKGNM}.txt
  
  ${E} "Verifying ${SWNM} installation"
  ${swverify} -fm3 ${SWNM} > ${dest_dir}/swverify-${SWNM}.txt 2>&1

  ${E} "Capture license key validation information"
  ${E} "Capture the output of dtcinfo"
  (
  $dtcbindir/dtcinfo -v
  $dtcbindir/dtclicinfo
  $dtcbindir/dtchostinfo
  $dtcbindir/dtcinfo -a
  ) > ${dest_dir}/dtcinfo.txt 2>&1
  
  ${E} "Capture Pstore(s) main headers and groups and devices structures"
  $dtcbindir/dtcinfo -a -s > ${dest_dir}/dtc_pstore_info.txt 2>&1

  ${E} "Capture tunable parameters of Mobility groups "
  if [ -f ${dtccfgdir}/p[0-9][0-9][0-9].cfg ]
  then
    for cfgFile in ${dtccfgdir}/p[0-9][0-9][0-9].cfg 
    do
      tmpStr=`${basename} $cfgFile | ${sed} "s/p//" | ${sed} "s/.cfg//"`
      ${E} "---  Mobility Group ${tmpStr} ---"
      ${dtcbindir}/dtcset -g ${tmpStr}
      ${E} ""
    done > ${dest_dir}/dtcset.txt 2>&1
  fi

  Journals=`${grep} -h JOURNAL: ${dtccfgdir}/s[0-9][0-9][0-9].cfg 2>/dev/null |
    	 ${sed} -e 's/JOURNAL://'|${sort} -u`
  if [ -n "${Journals}" ]
  then
    ${E} "Verify Journal Space"
    (
    ${E} Journals=${Journals} 
    ${E} ${df} ${Journals}
    ${df} ${Journals}
    ${E} ${ls} -l ${Journals}
    ${ls} -l ${Journals}
    ) > ${dest_dir}/dtcJournals.txt 2>&1
  fi
  
  PingPrefix="-c 10"
  PingSuffix=""
  
  PINGROUTE=0
  for cmds in $ping $sort $tr 
  do
  	test -x $cmds || PINGROUTE=1
  done
  
  if [ "$PINGROUTE" = 1 ]
  then
    ${E} "Cannot check ping"
  else
    ${E} "Checking connectivity to Mobility hosts"
    ${grep} HOST ${dtccfgdir}/?[0-9][0-9][0-9].cfg > ${dest_dir}/ping.txt 2>&1
    HOSTS=`${grep} -h HOST ${dtccfgdir}/?[0-9][0-9][0-9].cfg 2>/dev/null |
    	 ${sed} -e 's/HOST://'| ${tr} -d " \t" |${sort} -u`
    if [ -n "${HOSTS}" ]
    then
      ${E} ${HOSTS}
      for TARGHOST in $HOSTS
      do
        ${E} "++++++++++++++++++++[ $TARGHOST ]:" 
        ${E} ${ping} ${PingPrefix} $TARGHOST ${PingSuffix}
        ${ping} ${PingPrefix} $TARGHOST ${PingSuffix} 2>&1 
      done >>${dest_dir}/ping.txt
    else
      ${E} "No Mobility hosts defined"
      ${E} "No Mobility hosts defined" > ${dest_dir}/ping.txt
    fi
  fi

else
	${E} SFTKdtc is not installed.
fi	# -x ${dtcbindir}/dtcinfo 

######################################################################
# end of dtc specific tasks
######################################################################


  ${E} "######################################################################
# start of tdmf specific tasks
######################################################################"

PKGNM="SFTKtdmf"
SWNM=tdmf.rte
install_dir=/var/opt/${PKGNM}
tdmfbindir=/usr/SFTKtdmf/bin/
tdmfvardir=/var/opt/${PKGNM}
tdmfcfgdir=/etc/opt/${PKGNM}
tdmfdrvdir=/usr/lib/drivers
tdmfdrv=$tdmfdrvdir/TDMF

tdmf=${tdmfbindir}/tdmf

if [ -d $tdmfvardir ]
then
  mkdir -p ${dest_dir}/${tdmfvardir} &&
    ${cp_r} -f ${tdmfvardir}/* ${dest_dir}/${tdmfvardir} 2> /dev/null
fi

if [ -x ${tdmf} ]
then
# do more only if we are installed.

  ${E} "Capture tdmf specific info"

  ${tdmf} lic       > ${dest_dir}/tdmflicinfo.txt 2>&1
  ${tdmf} set       > ${dest_dir}/tdmfset.txt 2>&1
  ${tdmf} status -l > ${dest_dir}/tdmfstatus.txt 2>&1
  ${tdmf} dbdump    > ${dest_dir}/tdmfdbdump.txt 2>&1

  mkdir -p ${dest_dir}/${tdmfcfgdir} &&
    ${cp_r} -f ${tdmfcfgdir}/* ${dest_dir}/${tdmfcfgdir}/	2>/dev/null

  test -f /etc/tdmf/lib/tdmflparid.cfg && 
    mkdir -p ${dest_dir}/etc/tdmf/lib/ &&
      ${cp_r} -f /etc/tdmf/lib/tdmflparid.cfg ${dest_dir}/etc/tdmf/lib/	2>/dev/null

  (
   ${E} "++++++++++++++++++++[ tdmf version ]:" 
   ${tdmf} version 
   for execute in ALLVMGROUPS ALLVMVOLUMES ALLMIGGROUPS ALLMIGVOLUMES 
   do
   	${E} "++++++++++++++++++++[ tdmf list +${execute} ]:" 
   	${tdmf} list +${execute}
   done 
  ) > ${dest_dir}/tdmfinfo.txt 2>&1
  
  ${ls} -laRF ${install_dir} >${dest_dir}/ls--tdmfinstall_dir.txt
  ${ls} -laRF ${tdmfvardir} >${dest_dir}/ls--tdmfvardir.txt
  ${ls} -laRF ${tdmfcfgdir} >${dest_dir}/ls--tdmfcfgdir.txt
  ${ls} -laRF ${tdmfdrvdir} ${tdmfldrvdir} ${tdmfidrvdir} >${dest_dir}/ls--tdmfdrvdir.txt
  
  ${E} "Verifying binaries"
  
  ${tdmf} version > ${dest_dir}/bin-info-${PKGNM}.txt
  for file in ${tdmfbindir}/* ${tdmfdrvdir}/* ${tdmfldrvdir} ${tdmfidrvdir} ; do
    if [ -f "${file}" ]
    then
      ${E} "----------" 
      ${ls} -laF ${file} 
      ${filetype} ${file} 
      ${sum} ${file} 
      ${strings} ${file} | ${grep} Version 
    fi
  done >> ${dest_dir}/bin-info-${PKGNM}.txt
  
  ${E} "Verifying ${SWNM} installation"
  ${swverify} -fm3 ${SWNM} > ${dest_dir}/swverify-${SWNM}.txt 2>&1

else
	${E} SFTKtdmf is not installed.
fi	# -x ${tdmf} 

######################################################################
# end of tdmf specific tasks
######################################################################




${E} "Making the diagnostic archive file ${archive}.tar.Z "
(
    cd ${work_dir} &&
    ${tar} -cf - ./${archive} 2>/dev/null | ${compress} > ${archive}.tar.Z &&
    ${rm} -rf ${archive} ${archive}.tar &&
    ${chmod} 600 ${archive}.tar.Z
    $test $? -eq 0 || ${E} error building archive
)

${ls} -l ${work_dir}/${archive}.tar.Z

exit 0
