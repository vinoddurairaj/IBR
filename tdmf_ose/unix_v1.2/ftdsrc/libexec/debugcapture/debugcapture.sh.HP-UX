#!/bin/ksh
LANG=C
export LANG

######################################################################
# Program:
# --------
# debugcapture (%VERSION%) for HP-UX
#
# LICENSED MATERIALS / PROPERTY OF IBM
# %PRODUCTNAME% version %VERSION%
# (c) Copyright %COMPANYNAME%  %COPYRIGHTYEAR 2001%.  All Rights Reserved.
# The source code for this program is not published or otherwise
# divested of its trade secrets, irrespective of what has been
# deposited with the U.S. Copyright Office.
# US Government Users Restricted Rights - Use, duplication or
# disclosure restricted by GSA ADP Schedule Contract with %COMPANYNAME%
#
#
# $RCSfile: debugcapture.sh.HP-UX,v $
# $Revision: 1.34 $
# $Date: 2012/02/13 22:12:23 $
#
# Usage:
# ------
#       nodename1# debugcapture
#       nodename1# debugcapture /tmp/work_dir
# ------------
#
# This program collects system and Replicator/TDMF/TDMF-IP information.
#

# Use built-in "echo"
E="echo"

id="/bin/id"
if [ `${id} -u` != 0 ]; then
    ${E} "Error: `${id}`
  One must be root." >&2
    exit 1
fi

if [ -z "$work_dir" ]
then
	work_dir="/tmp"
	if [ -z "$1" ]
	then
		${E} "
The working directory is \"${work_dir}\".
You may specify a directory for workspace and final output.
abort this script (ctrl-c) and specify a different directory if desired
	$0 work_dir
"
	/bin/sleep 5
	else
		work_dir="$1"
	fi
fi

#
# Define "check_executable" and "verify_executable".
#
check_executable() {
    if [ ! -x "${1}" ]; then
        ${E} "Warning: unable to find an executable \"${1}\"." >&2
    fi
}

verify_executable() {
    if [ ! -x "${1}" ]; then
        ${E} "Error: unable to find an executable \"${1}\"." >&2
        exit 1
    fi
}

#
# Verify executables.
#
# These are required:
awk="/bin/awk"
cat="/bin/cat"
cut="/usr/bin/cut"
egrep="/usr/bin/egrep"
grep="/usr/bin/grep"
id="/bin/id"
paste="/usr/bin/paste"
uname="/bin/uname"
xargs=/usr/bin/xargs

for command in ${awk} ${cat} ${cut} ${grep} ${egrep} ${id} ${uname}; do
    verify_executable ${command}
done

# Check the suitability of "${work_dir}".

if [ ! -d "${work_dir}" ]; then
    ${E} "Error: \"${work_dir}\" is not a directory." >&2
    ${E} "Error: The variable \"work_dir\" is not set correctly." >&2
    exit 1
else
    ${E} "The working directory is \"${work_dir}\"."
    ${E} ""
fi

#
# Display an informational message.
#
######################################################################
${E} "
This program will collect system and Softek TDMF/Replicator diagnostic
information.
"
######################################################################

#
# Set up command variables to be absolute pathnames.
#
# Required commands.
#
basename="/bin/basename"
chmod="/bin/chmod"
compress="/bin/compress"
cp="/bin/cp"
cp_r="/bin/cp -r -p"
cpio="/usr/bin/cpio"
date=/usr/bin/date
dirname="/bin/dirname"
find="/usr/bin/find"
ls="/bin/ls"
mkdir="/bin/mkdir"
rm="/bin/rm"
sed="/bin/sed"
strings="/bin/strings"
sum="/bin/sum"
tar="/bin/tar"
touch="/bin/touch"
#
req_commands="
    ${basename}
    ${chmod}
    ${compress}
    ${cp}
    ${dirname}
    ${ls}
    ${mkdir}
    ${rm}
    ${sed}
    ${sum}
    ${tar}
    ${touch}"
# Verify the executability of ${req_commands}.
#
# These are required:
for command in ${req_commands}; do
    verify_executable ${command}
done
#
# Set up destination directory and file names.
#
archive=`${uname} -n`.`${date} +\%Y\%m\%d-\%H\%M`
dest_dir="${work_dir}/${archive}"
data_file="${dest_dir}/misc_info.txt"

(
    cd ${work_dir}
    ${rm} -rf ${archive} ${archive}.tar.Z 
)

${mkdir} -p ${dest_dir}; ${chmod} 700 ${dest_dir}

#
# Define cleanup function and install interrupt handler
#
cleanup() {
(
    cd ${work_dir}
    ${rm} -rf ${archive} ${archive}.tar.Z 
)
exit 1
}

trap cleanup 1 2 3 4 10 15
#
# Optional commands for system data generation.
#
arpinfo="/usr/sbin/arp -an"
crashconf="/sbin/crashconf"
df="/bin/df"
dmesg="/usr/sbin/dmesg"
filetype="/usr/bin/file"
getconf="/usr/bin/getconf"
ifconfig="/usr/sbin/ifconfig"
iostat=/usr/bin/iostat
ipcs="/bin/ipcs"
kcmodule=/usr/sbin/kcmodule
kctune="/usr/sbin/kctune"
kmadmin="/usr/sbin/kmadmin"
kmtune="/usr/sbin/kmtune"
lanscan="/usr/sbin/lanscan"
lsdev="/usr/sbin/lsdev"
model="/usr/bin/model"
mount="/usr/sbin/mount"
ndd="/usr/bin/ndd"
netstat="/bin/netstat"
ps="/bin/ps"
sar="/usr/sbin/sar"
sort=/usr/bin/sort
swapinfo="/usr/sbin/swapinfo"
swlist="/usr/sbin/swlist"
swverify="/usr/sbin/swverify"
sysdef="/usr/sbin/sysdef"
tail="/bin/tail"
true="/bin/true"
ulimit="/usr/bin/ulimit -a"
uptime=/usr/bin/uptime
vmstat=/usr/bin/vmstat
who=/usr/bin/who
cmviewcl=/usr/sbin/cmviewcl
cmviewconf=/usr/sbin/cmviewconf
#
# Optional functions for system data generation.
#
#
# Capture hostid
#
hostid () {
    ${uname} -i | ${awk} '{printf("0x%x\n", $1)}'
}
#
#
lvdisplay="/usr/sbin/lvdisplay"
pvdisplay="/usr/sbin/pvdisplay"
vgdisplay="/usr/sbin/vgdisplay"
VOLFILE="${dest_dir}/volume_group_info.txt"
if [ -x "${vgdisplay}" -a -x "${lvdisplay}" -a -x "${pvdisplay}" ]
then
  ${E} Capture Logical Group Data
  ${E} "++++++++++++++++++++[ ${vgdisplay} ${lv} ]:" > $VOLFILE
  ${vgdisplay} -v >> $VOLFILE 2>&1

  ${E} Capture Logical Volume Data
  lvs=`${vgdisplay} -v 2>/dev/null | ${awk} '$0 ~ /LV Name/ {print $3}'`
  for lv in ${lvs}; do
    ${E} "++++++++++++++++++++[ ${lvdisplay} ${lv} ]:"
    ${lvdisplay} ${lv} 
  done  >> $VOLFILE 2>&1

  ${E} Capture Physical Volume Data
  pvs=`${vgdisplay} -v 2>/dev/null | ${awk} '$0 ~ /PV Name/ {print $3}'`
  for pv in ${pvs}; do
    ${E} "++++++++++++++++++++[ ${pvdisplay} ${pv} ]:" 
    ${pvdisplay} ${pv} 
  done  >> $VOLFILE 2>&1
fi

# VxVM (vxfs) specific.
# This data is very large, and not normally useful for debug
#
#vxvm="/etc/vx"
#if [ -d "${vxvm}" ]
#then
#    ${E} "Capture VxVM files "
#    ${mkdir} -p ${dest_dir}/${vxvm}
#    ${cp_r} -p ${vxvm} ${dest_dir}/	2>/dev/null
#fi

vxdg="/usr/sbin/vxdg"
vxdisk="/usr/sbin/vxdisk"
vxinfo="/usr/sbin/vxinfo"
vxprint="/usr/sbin/vxprint"

if [ -x "${vxdg}" -a -x "${vxprint}" ]; then
    ${E} "Capture Veritas volume group and volume definitions"
    (
	${E} "++++++++++++++++++++[ ${vxdisk} list ]:" 
	${vxdisk} list 

	${E} "++++++++++++++++++++[ ${vxdg} list ]:" 
	${vxdg} list 

	for VXGroup in `${vxdg} -q list  |cut -d' ' -f1 `
	do
	  $E ++++++++++++++++++++ [ ${vxinfo} -g ${VXGroup} ]
	  ${vxinfo} -g ${VXGroup}
	done

	${E} "++++++++++++++++++++[ ${vxprint} ]:" 
	${vxprint} 
	) > ${dest_dir}/vxdata.txt  2>&1
fi

command00=${date}
command01="${true} && hostid"
command02="${uname} -a"
command03="${df} -k"
command04="${mount}"
command06="${iostat}"
command07="${vmstat}"
command10="${arpinfo}"
command12="${sysdef}"
command13="${dmesg}"
command14="${ipcs} -a"
command15="${swapinfo}"
command16="${ulimit}"
#
# Note: The commands are executed in the order
#       of top to bottom to generate system data.
#
data_commands='
${command00}
${command01}
${command02}
${command03}
${command04}
${command06}
${command07}
${command10}
${command12}
${command13}
${command14}
${command15}
${command16}'

# Note: The use of "check_executable ${command}" will work when
#       "${command}" has the form "<command> <flags>".  This usage
#       could give somewhat misleading information in some cases,
#       for example, "/bin/echo y | <command>".

${E} "Capture generic system data"
${E} ' debugcapture (%VERSION%.%BUILDNUM%) for HP-UX
 $Date: 2012/02/13 22:12:23 $ ' > ${data_file}
for command in ${data_commands}
do
    eval execute="${command}"
    ${E} "++++++++++++++++++++[ ${execute} ]:" >> ${data_file} 
    result=`check_executable ${execute} 2>&1`
    if [ -z "${result}" ]; then
        eval ${execute} >> ${data_file} 2>&1
    else
        ${E} "${result}" >> ${data_file}
    fi
    ${E} "" >> ${data_file}
done
${E} ""

files="/etc/auto_*
    /etc/cmcluster.conf
    /etc/cmcluster/
    /etc/exports
    /etc/fstab*
    /etc/hosts*
    /etc/inetd.conf
    /etc/inittab
    /etc/ioconfig
    /etc/lvmrc
    /etc/mnttab
    /etc/mrouted.conf
    /etc/networks
    /etc/nsswitch.conf
    /etc/rc*
    /etc/resolv.conf
    /etc/rpc
    /etc/services
    /etc/shutdownlog
    /etc/syslog.conf
    /ioconfig
    /sbin/rc*
    /sbin/init.d
    /stand/ioconfig
    /stand/system
    "

#
${E} "Capture system config files"
( 
  test -n "${files}" && ${find} ${files} | ${cpio} -pdum ${dest_dir}/
) 2> /dev/null

${E} "Capture syslog files "
files=`${grep} -v "^#" /etc/syslog.conf | ${sed} -e 's/-\///' |
	${xargs} ${filetype} |${grep} text|${cut} -d: -f1`
test -n "${files}" && ${ls} ${files} | ${cpio} -pdum ${dest_dir}/	2>/dev/null

#
# Copy OS specific log files.
#

${E} "Capture system log files"
logs="/etc/rc.log /etc/shutdownlog /var/adm/* /var/adm/syslog/*syslog*"
${mkdir} -p ${dest_dir}/var/adm/syslog/
for log in ${logs}; do
    if [ -f ${log} ]; then
        ${filetype} ${log} | ${grep} text > /dev/null &&
            ${cp} -p ${log} ${dest_dir}/${log}	2>/dev/null
    fi
done

#
# Copy LVM specific files.
#
lvm="/etc/lvmconf"
if [ -d "${lvm}" ]
then
 ${E} "Capture LVM conf files "
 ${mkdir} -p ${dest_dir}${lvm}/
 ${cp_r} -f ${lvm} ${dest_dir}${lvm}/	2>/dev/null
fi
#
# Generate the "rc" listing.
#
${ls} -laRF /etc/rc* /sbin/rc* >${dest_dir}/ls--rc.txt

${E} "++++++++++++++++++++[ ${who} -b ]:" > ${dest_dir}/ps-output.txt
${who} -b  >> ${dest_dir}/ps-output.txt
${E} "++++++++++++++++++++[ ${uptime} ]:" >> ${dest_dir}/ps-output.txt
${uptime} >> ${dest_dir}/ps-output.txt

${E} "Capture running processes"
${E} "++++++++++++++++++++[ ${ps} -el ]:" >> ${dest_dir}/ps-output.txt
${ps} -el >>${dest_dir}/ps-output.txt
${E} "++++++++++++++++++++[ ${ps} -ef ]:" >> ${dest_dir}/ps-output.txt
${ps} -ef >>${dest_dir}/ps-output.txt

if [ -x ${sar} ]
then
  ${E} "Capture system activity report"
  ${E} "++++++++++++++++++++[ ${sar} -du 5 ]:" > ${dest_dir}/sar-output.txt
  ${sar} -du 5 >> ${dest_dir}/sar-output.txt
fi

${E} "Capture driver listings"
${lsdev} >${dest_dir}/lsdev.txt

if [ -x ${kcmodule} ]
then
	${kcmodule} -v > ${dest_dir}/kcmodule.txt
fi

if [ -x ${kmadmin} ]
then
  for KM in k s S
  do
	${E} "++++++++++++++++++++[ ${kmadmin} -${KM} ]:"
	${kmadmin} -${KM} 
  done >${dest_dir}/kmadmin.txt 2>&1
fi

${E} "Capture crash configuration"
${crashconf} -v >  ${dest_dir}/crashconf.txt 2>&1

${E} "Capture kernel information"
test -d /usr/conf/master.d &&
	(cd /usr/conf; ${tar} -cf ${dest_dir}/master.d.tar master.d)

if [ -x ${kctune} ]
then
	${kctune} -v > ${dest_dir}/kctune-full.txt 2>&1
	if [ -x ${paste} ]
	then
		${paste} - - - - - - - - - < ${dest_dir}/kctune-full.txt |
			${cut} -f1,2 > ${dest_dir}/kctune.txt
	fi
fi

# We'll run kmtune only if kctune hasn't run yet.
if [ -x ${kmtune} -a ! -f ${dest_dir}/kctune-full.txt ]
then
	${kmtune} -l > ${dest_dir}/kmtune-full.txt 2>&1
	if [ -x ${paste} ]
	then
		${paste} - - - - - - - - - < ${dest_dir}/kmtune-full.txt |
			${cut} -f1,2 > ${dest_dir}/kmtune.txt 2>&1
	fi
fi

${E} "Capture hardware information"
(
 ${uname} -a

 ${model}

 getconfs='
 CPU_CHIP_TYPE
 CPU_VERSION
 HW_32_64_CAPABLE
 HW_CPU_SUPP_BITS
 KERNEL_BITS
 MACHINE_IDENT
 MACHINE_MODEL
 MACHINE_SERIAL
 PARTITION_IDENT
 '
 for confopt in $getconfs
 do
	echo $confopt `$getconf $confopt`
 done 
) > ${dest_dir}/getconf.txt 2>&1

ioscan=/usr/sbin/ioscan
if [ -x "${ioscan}" ]
then
	${ioscan} -fun > ${dest_dir}/ioscan.txt 2>&1
fi

for file in /stand/*vmuni*; do
    ${E} "----------" 
    ${E} ${ls} -laF ${file} 
    ${ls} -laF ${file} 
    ${E} ${filetype} ${file} 
    ${filetype} ${file} 
    ${E} ${sum} ${file}
    ${sum} ${file}
    ${E} "${strings} ${file} | ${grep} Version"
    ${strings} ${file} | ${grep} Version
done>> ${dest_dir}/bin-info-vmunix.txt 2>&1

if [ -x ${cmviewcl} ]
then
	${E} "Capture ServiceGuard information"
    (
	${E} "++++++++++++++++++++[ ${cmviewcl} ]:"
	${cmviewcl} 
	${E} "++++++++++++++++++++[ ${cmviewconf} ]:"
	${cmviewconf}
    ) > ${dest_dir}/ServiceGuard.txt 2>&1
fi

${E} "Capture software installations"
(
  ${E} "++++++++++++++++++++[ ${swlist} ]:"
  ${swlist} 
  ${E} "++++++++++++++++++++[ ${swlist} -v ]:" 
  ${swlist} -v 
) > ${dest_dir}/swlist.txt 2>&1

${ls} -laRF /dev >${dest_dir}/ls--dev.txt
${ls} -laRF /var/adm >${dest_dir}/ls--var_adm.txt
  

# Network items aren't needed for TDMF, but pre-install survey
# captures some data here anyway.

if [ -x ${netstat} ]
then
  ${E} "Capture all of the netstat arguments individually"
  nets_file="${dest_dir}/netstat.txt"
  for netstats in s rn v m i in an s
  do
      ${E} "++++++++++++++++++++[ ${netstat} -${netstats} ] "
  	${netstat} -${netstats}
  done > ${nets_file} 2>&1
fi


if [ -x "${lanscan}" -a -x "${ifconfig}" ]
then
  ${E} "Capture network tuning "
	(
	${E} "+++++++ [ ${lanscan} ]"
	${lanscan} 
        interfaces=`${lanscan} | \
            ${awk} '$0 !~ /Hardware|Path|Station|Address|MAC|ID/{print $5}'`
            
        for interface in ${interfaces}
	do
          ${E} "+++++++++++[ ${ifconfig} ${interface} ]:" 
          ${ifconfig} ${interface} 
	  ${E} ""
        done 
	) > ${dest_dir}/net_tune.txt 2>&1
fi

if [ -x ${ndd} ]
then
  for Module in tcp ip udp 
  do
    ${E} +++++++ ${ndd} /dev/${Module} Param 
    for Param in `${ndd} /dev/${Module} \? |
	${cut} -d' ' -f1|
	${egrep} -vi stats\|hash\|obsolete`
    do
	${E} $Param  `${ndd} /dev/${Module} $Param ` 
    done | ${cut} -c1-70
  done >> ${dest_dir}/net_tune.txt 2>&1
fi


######################################################################
# generic system survey down to here.
# perform Replicator specific checks, then TDMF, each as available
######################################################################

${E} "
######################################################################
# start of Replicator specific tasks
######################################################################
"

PKGNM="SFTKdtc"
SWNM="DTC"
install_dir=/opt/${PKGNM}
dtcbindir=${install_dir}/bin
dtccfgbase=/etc/opt/${PKGNM}
dtccfgdir=${dtccfgbase}
dtcvardir=/var/opt/${PKGNM}
dtcdrvdir=/stand/build/mod_wk.d/dtc
dtcldrvdir=/stand/dlkm/*/dtc
dtcidrvdir=/stand/current/mod/dtc

if [ -d ${dtcvardir} ]
then
	${mkdir} -p ${dest_dir}/${dtcvardir} &&
	    ${cp_r} -f ${dtcvardir}/* ${dest_dir}/${dtcvardir}	2>/dev/null
fi
  
${mkdir} -p ${dest_dir}/tmp &&
      ${cp} -f -p /tmp/in.???.log ${dest_dir}/tmp 2> /dev/null

# do more only if we are installed.

if [ -x ${dtcbindir}/dtcinfo ]
then

  ${E} "Capture directory listings"
  ${ls} -laRF ${install_dir} >${dest_dir}/ls--dtcinstall_dir.txt
  ${ls} -laRF  ${dtccfgbase} >${dest_dir}/ls--dtccfgdir.txt
  ${ls} -laRF  ${dtcvardir} >${dest_dir}/ls--dtcvardir.txt
  ${ls} -laRF  ${dtcdrvdir} ${dtcldrvdir} ${dtcidrvdir} >${dest_dir}/ls--dtcdrvdir.txt 2>&1
  
  ${E} "Capture $PKGNM files"
  ${mkdir} -p ${dest_dir}/${dtccfgbase} &&
    ${cp_r} -f ${dtccfgbase}/* ${dest_dir}/${dtccfgbase}/	2>/dev/null

  ${find} /stand | ${grep} dtc |cpio -pdm ${dest_dir}/
  
  



  ${E} "Verifying dtc binaries"
  ${E} dtcinfo -v >  ${dest_dir}/bin-info-${PKGNM}.txt 2>&1
  ${dtcbindir}/dtcinfo -v >> ${dest_dir}/bin-info-${PKGNM}.txt
  for file in ${dtcbindir}/* ${dtcdrvdir}/* ${dtcldrvdir} ${dtcidrvdir} \
	/usr/conf/lib/libdtc.a /stand/build/bab.o
  do
    if [ -f "${file}" ]
    then
      ${E} "----------" 
      ${ls} -laF ${file} 
      ${filetype} ${file} 
      ${sum} ${file} 
      ${strings} ${file} | ${grep} Version 
    fi
  done >> ${dest_dir}/bin-info-${PKGNM}.txt
  
  ${E} "Verifying ${SWNM} installation"
  ${swverify} -x mount_all_filesystems=FALSE ${SWNM} > ${dest_dir}/swverify-${SWNM}.txt 2>&1

  ${E} "Capture license key validation information"
  ${E} "Capture the output of dtcinfo"
  (
  $dtcbindir/dtcinfo -v
  $dtcbindir/dtclicinfo
  $dtcbindir/dtchostinfo
  $dtcbindir/dtcinfo -a
  ) > ${dest_dir}/dtcinfo.txt 2>&1

  ${E} "Capture Pstore(s) main headers and groups and devices structures"
  $dtcbindir/dtcinfo -a -s > ${dest_dir}/dtc_pstore_info.txt 2>&1

  ${E} "Capture tunable parameters of Mobility groups "
  if [ -f $dtccfgdir/p[0-9][0-9][0-9].cfg ]
  then
    for cfgFile in $dtccfgdir/p[0-9][0-9][0-9].cfg 
    do
      tmpStr=`${basename} $cfgFile | ${sed} "s/p//" | ${sed} "s/.cfg//"`
      ${E} "---  Mobility Group ${tmpStr} ---"
      ${dtcbindir}/dtcset -g ${tmpStr}
      ${E} ""
    done > ${dest_dir}/dtcset.txt 2>&1
  fi
  
  Journals=`${grep} -h JOURNAL: $dtccfgdir/s[0-9][0-9][0-9].cfg 2>/dev/null |
    	 ${sed} -e 's/JOURNAL://'|${sort} -u`
  if [ -n "${Journals}" ]
  then
    ${E} "Verify Journal Space"
    (
    ${E} Journals=${Journals} 
    ${E} ${df} ${Journals}
    ${df} ${Journals}
    ${E} ${ls} -l ${Journals}
    ${ls} -l ${Journals}
    ) > ${dest_dir}/dtcJournals.txt 2>&1
  fi
  
  ping=/usr/sbin/ping

  tr="/usr/bin/tr"
  
  PingPrefix=""
  PingSuffix="-n 10"

  PINGROUTE=0
  for cmds in $cut $ping $sort $tr 
  do
  	test -x $cmds || PINGROUTE=1
  done
  
  if [ "$PINGROUTE" = 1 ]
  then
    ${E} "Cannot check ping"
  else
    ${E} "Checking connectivity to Mobility hosts"
    ${grep} HOST $dtccfgdir/?[0-9][0-9][0-9].cfg > ${dest_dir}/ping.txt 2>&1
    HOSTS=`${grep} -h HOST $dtccfgdir/?[0-9][0-9][0-9].cfg 2>/dev/null |
  	 ${sed} -e 's/HOST://'| ${tr} -d " \t" |${sort} -u`
    if [ -n "${HOSTS}" ]
    then
      ${E} ${HOSTS}
      for TARGHOST in $HOSTS
      do
        ${E} "++++++++++++++++++++[ $TARGHOST ]:" 
        ${E} ${ping} ${PingPrefix} $TARGHOST ${PingSuffix}
        ${ping} ${PingPrefix} $TARGHOST ${PingSuffix} 2>&1 
      done >>${dest_dir}/ping.txt 2>&1
    else
      ${E} "No Mobility hosts defined"
      ${E} "No Mobility hosts defined" > ${dest_dir}/ping.txt
    fi
  fi
else
	${E} SFTKdtc is not installed.
fi	# -x ${dtcbindir}/dtcinfo 

######################################################################
# end of Replicator specific tasks
######################################################################


${E} "
######################################################################
# start of tdmf specific tasks
######################################################################
"
PKGNM="SFTKtdmf"
SWNM=${PKGNM}
install_dir=/opt/${PKGNM}
tdmfbindir=${install_dir}/bin
tdmfcfgdir=/etc/opt/${PKGNM}
tdmfvardir=/var/opt/${PKGNM}
tdmf=${tdmfbindir}/tdmf

if [ -d $tdmfvardir ]
then
    ${mkdir} -p ${dest_dir}/${tdmfvardir} &&
    ${cp_r} -f ${tdmfvardir}/* ${dest_dir}/${tdmfvardir}	2>/dev/null
fi

if [ -x ${tdmf} ]
then
# do more only if we are installed.
  tdmfdrvdir=/stand/build/mod_wk.d/migdriver
  tdmfldrvdir=/stand/dlkm/*/migdriver
  tdmfidrvdir=/stand/current/mod/migdriver

  ${E} "Capture tdmf specific info"

  mkdir -p ${dest_dir}/${tdmfcfgdir} &&
    ${cp_r} -f ${tdmfcfgdir}/* ${dest_dir}/${tdmfcfgdir}/	2>/dev/null

  test -f /etc/tdmf/lib/tdmflparid.cfg && 
    mkdir -p ${dest_dir}/etc/tdmf/lib/ &&
      ${cp_r} -f /etc/tdmf/lib/tdmflparid.cfg ${dest_dir}/etc/tdmf/lib/	2>/dev/null

  ${tdmf} lic       > ${dest_dir}/tdmflicinfo.txt 2>&1
  ${tdmf} set       > ${dest_dir}/tdmfset.txt 2>&1
  ${tdmf} status -l > ${dest_dir}/tdmfstatus.txt 2>&1
  ${tdmf} dbdump    > ${dest_dir}/tdmfdbdump.txt 2>&1

  (
   ${E} "++++++++++++++++++++[ tdmf version ]:" 
   ${tdmf} version 
   for execute in ALLVMGROUPS ALLVMVOLUMES ALLMIGGROUPS ALLMIGVOLUMES 
   do
   	${E} "++++++++++++++++++++[ tdmf list +${execute} ]:" 
   	${tdmf} list +${execute}
   done 
  ) > ${dest_dir}/tdmfinfo.txt 2>&1
  
  ${ls} -laRF ${install_dir} >${dest_dir}/ls--tdmfinstall_dir.txt
  ${ls} -laRF ${tdmfvardir} >${dest_dir}/ls--tdmfvardir.txt
  ${ls} -laRF ${tdmfcfgdir} >${dest_dir}/ls--tdmfcfgdir.txt
  ${ls} -laRF ${tdmfdrvdir} ${tdmfldrvdir} ${tdmfidrvdir} >${dest_dir}/ls--tdmfdrvdir.txt 2>&1
  
  ${E} "Capture some $PKGNM files"
  ${find} /stand | ${grep} mig |cpio -pdm ${dest_dir}/
  
  ${E} "Verifying binaries"
  
  ${tdmf} version > ${dest_dir}/bin-info-${PKGNM}.txt
  for file in ${tdmfbindir}/* ${tdmfdrvdir}/* ${tdmfldrvdir} ${tdmfidrvdir} ; do
    if [ -f "${file}" ]
    then
      ${E} "----------" 
      ${ls} -laF ${file} 
      ${sum} ${file} 
      ${strings} ${file} | ${grep} Version 
    fi
  done >> ${dest_dir}/bin-info-${PKGNM}.txt
  
  ${E} "Verifying ${SWNM} installation"
  ${swverify} -x mount_all_filesystems=FALSE ${SWNM} > ${dest_dir}/swverify-${SWNM}.txt 2>&1

else
	${E} SFTKtdmf is not installed.
fi	# -x ${tdmf} 

######################################################################
# end of tdmf specific tasks
######################################################################

${cp} /var/adm/sw/swagent.log ${dest_dir}/	2>/dev/null

${E} "######################################################################"
${E} "Making the archive "
(
    cd ${work_dir}
    ${tar} -cf - ./${archive} 2>/dev/null | ${compress} > ${archive}.tar.Z
    ${rm} -rf ${archive} ${archive}.tar 
    ${chmod} 600 ${archive}.tar.Z
)

${cat} <<EOF

Done:
-----
`${ls} -l ${work_dir}/${archive}.tar.Z`

EOF
exit 0
