#!/bin/ksh
########################################################################
#
# debugcapture (%VERSION%) for Solaris
#
# LICENSED MATERIALS / PROPERTY OF IBM
# %PRODUCTNAME% version %VERSION%
# (c) Copyright %COMPANYNAME%  %COPYRIGHTYEAR 2001%.  All Rights Reserved.
# The source code for this program is not published or otherwise
# divested of its trade secrets, irrespective of what has been
# deposited with the U.S. Copyright Office.
# US Government Users Restricted Rights - Use, duplication or
# disclosure restricted by GSA ADP Schedule Contract with %COMPANYNAME%
#
#
# $RCSfile: debugcapture.sh.SunOS,v $
# $Revision: 1.35 $
# $Date: 2012/02/13 22:12:23 $
#
########################################################################

unalias -a
LANG=C
export LANG

########################################################################
#
# Description:
# ------------
# This program will capture system, Replicator, TDMF, and TDMF-IP 
# configuration and state information.  
#
######################################################################

# Use built-in "echo"
E="echo"

id="/usr/bin/id"
if [ `${id} -u` != 0 ]; then
    ${E} "Error: `${id}`
  One must be root." >&2
    exit 1
fi

if [ -z "$work_dir" ]
then
	work_dir="/tmp"
	if [ -z "$1" ]
	then
		${E} "
The working directory is \"${work_dir}\".
You may specify a directory for workspace and final output.
abort this script (ctrl-c) and specify a different directory if desired
	$0 work_dir
"
	/bin/sleep 5
	else
		work_dir="$1"
	fi
fi

# Define "check_executable" and "verify_executable".
check_executable() {
    if [ ! -x "${1}" ]; then
        ${E} "Warning: unable to find an executable \"${1}\"." >&2
    fi
}

verify_executable() {
    if [ ! -x "${1}" ]; then
        ${E} "Error: unable to find an executable \"${1}\"." >&2
        exit 1
    fi
}

# Verify executables.

# These are required:
awk="/bin/awk"
cat="/bin/cat"
cut="/usr/bin/cut"
find=/usr/bin/find
grep="/bin/grep"
egrep="/usr/bin/egrep"
id="/bin/id"
pkginfo="/usr/bin/pkginfo"
tr="/usr/bin/tr"
uname="/bin/uname"
sum="/usr/bin/sum"
strings="/usr/bin/strings"

for command in ${awk} ${cat} ${id} ${egrep} ${grep} ${pkginfo} ${uname}; do
    verify_executable ${command}
done

# Check the suitability of "${work_dir}".

if   [ ! -d "${work_dir}" ]; then
    ${E} "Error: \"${work_dir}\" is not a directory." >&2
    ${E} "Error: The variable \"work_dir\" is not set correctly." >&2
    exit 1
else
    ${E} "The working directory is \"${work_dir}\"."
    ${E} ""
fi

# Display an informational message.

${E} "
This program will capture system, Replicator, TDMF, and TDMF-IP 
configuration and state information.  
"

# Set up command variables to be absolute pathnames.
# Required commands.
basename="/bin/basename"
chmod="/bin/chmod"
compress="/bin/compress"
cp="/bin/cp"
cp_r="/bin/cp -Rfp"
dirname="/bin/dirname"
ls="/bin/ls"
mkdir="/bin/mkdir"
rm="/bin/rm"
sed="/bin/sed"
tar="/usr/sbin/tar"
touch="/bin/touch"
#
req_commands="
    ${basename}
    ${chmod}
    ${compress}
    ${cp}
    ${dirname}
    ${ls}
    ${mkdir}
    ${rm}
    ${sed}
    ${tar}
    ${touch}"
#
# Optional commands for system data generation.
#
cpio=/usr/bin/cpio
crash="/usr/sbin/crash"
date=/bin/date
df="/usr/sbin/df"
dmesg="/usr/sbin/dmesg"
eeprom="/usr/sbin/eeprom"
filetype="/usr/bin/file"
ifconfig="/usr/sbin/ifconfig"
iostat=/usr/bin/iostat
ipcs="/bin/ipcs"
modinfo="/usr/sbin/modinfo"
mount="/sbin/mount"
nawk="/bin/nawk"
ndd="/usr/sbin/ndd"
netstat="/bin/netstat"
ping=/usr/sbin/ping
pkgchk="/usr/sbin/pkgchk"
prtvtoc="/usr/sbin/prtvtoc"
ps="/bin/ps"
sar="/usr/sbin/sar"
showrev="/bin/showrev"
sort="/usr/bin/sort"
swap="/usr/sbin/swap"
sysdef="/usr/sbin/sysdef"
tail="/bin/tail"
true="/bin/true"
uptime=/usr/bin/uptime
vmstat=/usr/bin/vmstat
who=/usr/bin/who
xargs=/usr/bin/xargs

[ `${uname} -r` != "5.4" ] && \
   prtdiag="/usr/platform/`uname -i`/sbin/prtdiag" || \
      prtdiag="prtdiag"

command00="${date}"
command01="${uname} -a"
command02="${sysdef} -h"
command03="${cat} /etc/motd"
command04="${showrev}"
command05="${showrev} -p"
command06="${df} -k"
command07="${mount}"
command08="${iostat} -nE"
command09="${vmstat}"
command10="${swap} -s"
command11="${swap} -l"
command12="${ifconfig} -a"
command13="${modinfo}"
command14="${sysdef}"
command15="${eeprom}"
command16="${dmesg}"
command17="${prtdiag} -v"
command18="${ipcs} -a"

# Note: The commands are executed in the order
#       of top to bottom to generate system data.
#
data_commands='
    ${command00}
    ${command01}
    ${command02}
    ${command03}
    ${command04}
    ${command05}
    ${command06}
    ${command17}
    ${command07}
    ${command08}
    ${command09}
    ${command10}
    ${command11}
    ${command12}
    ${command13}
    ${command14}
    ${command15}
    ${command16}
    ${command17}
    ${command18}
    '
#
# Verify the executability of ${req_commands}.
#
# These are required:
for command in ${req_commands}; do
    verify_executable ${command}
done

#
# Set up list of files to archive.
#
files="/etc/auto_*
    /etc/defaultdomain
    /etc/defaultrouter
    /etc/dfs/
    /etc/gateways
    /etc/hostname.*
    /etc/hosts*
    /etc/inetd.conf
    /etc/init.d/
    /etc/inittab
    /etc/name_to_major
    /etc/netmasks
    /etc/nodename
    /etc/notrouter
    /etc/nsswitch.conf
    /etc/path_to_inst
    /etc/rc*
    /etc/resolv.conf
    /etc/rpc
    /etc/services
    /etc/system
    /etc/vfstab*
    /sbin/rc*
    "
#
# Set up destination directory and file names.
#
archive=`${uname} -n`.`${date} +\%Y\%m\%d-\%H\%M`
dest_dir="${work_dir}/${archive}"
data_file="${dest_dir}/misc_info.txt"

#
# Set up destination directory.
#
(
    cd ${work_dir}
    ${rm} -rf ${archive} ${archive}.tar ${archive}.tar.Z ${archive}.tar.Z.uu
)

${mkdir} ${dest_dir}; ${chmod} 700 ${dest_dir}

#
# Define cleanup function and install interrupt handler
#
cleanup() {
(
    cd ${work_dir}
    ${rm} -rf ${archive} ${archive}.tar ${archive}.tar.Z ${archive}.tar.Z.uu
)
exit 1
}

trap cleanup 1 2 3 4 10 15

#####################################################
## Start of generic OS routines
#####################################################

# Copy OS specific files.
${E} "Capture system config files"
( 
  test -n "${files}" && ${find} ${files} | ${cpio} -Lpdum ${dest_dir}/
) 2> /dev/null

${mkdir} -p ${dest_dir}/var/adm
${cp} -pf /var/adm/messages* ${dest_dir}/var/adm 2>/dev/null

${E} "Capture syslog files "
# suppressed on Solaris.  syslog.conf is irregular.
#files=`${grep} -v "^#" /etc/syslog.conf | ${sed} -e 's/-\///' |
#	${xargs} ${filetype} |${grep} text|${cut} -d: -f1`
#test -n "${files}" && ${ls} ${files} | ${cpio} -Lpdum ${dest_dir}/
${ls} /var/log/syslog* | ${cpio} -Lpdum ${dest_dir}/

if [ -x $crash ]
then
	${E} "Capture crash output"
	${E} p | ${crash} > ${dest_dir}/crash.txt 2>&1
fi

${E} "Capture file listings"
${ls} -laRF /etc/rc* > ${dest_dir}/ls--rc.txt
${ls} -laRF /dev >${dest_dir}/ls--dev.txt
${ls} -laRF /devices >${dest_dir}/ls--devices.txt
${ls} -laRF /var/crash >${dest_dir}/ls--var_crash.txt

${E} "++++++++++++++++++++[ ${who} -b ]:" > ${dest_dir}/ps-output.txt
${who} -b  >> ${dest_dir}/ps-output.txt
${E} "++++++++++++++++++++[ ${uptime} ]:" >> ${dest_dir}/ps-output.txt
${uptime} >> ${dest_dir}/ps-output.txt

# capture process information
${E} "Capture running processes"
${E} "++++++++++++++++++++[ ${ps} -el ]:" >> ${dest_dir}/ps-output.txt
${ps} -el >>${dest_dir}/ps-output.txt
${E} "++++++++++++++++++++[ ${ps} -ef ]:" >> ${dest_dir}/ps-output.txt
${ps} -ef >>${dest_dir}/ps-output.txt

if [ -x ${sar} ]
then
  ${E} "Capture system activity report"
  ${E} "++++++++++++++++++++[ ${sar} -ud 5 1 ]:" > ${dest_dir}/sar-output.txt
  ${sar} -ud 5 1 >> ${dest_dir}/sar-output.txt 2>&1
fi

if [ -x ${prtvtoc} ]
then
    ${E} Capture disk partition information.
	${prtvtoc} /dev/rdsk/c*t*d*s2 > ${dest_dir}/prtvtoc.txt  2>&1
fi

# Obtain VxVM data, if possible and if any.

vxdg="/usr/sbin/vxdg"
vxdisk="/usr/sbin/vxdisk"
vxinfo="/usr/sbin/vxinfo"
vxprint="/usr/sbin/vxprint"
vxdctl=/usr/sbin/vxdctl


if [ -x "${vxdg}" -a -x "${vxprint}" ]; then
    ${E} "Capture Veritas volume group and volume definitions"
    (
	${E} "++++++++++++++++++++[ ${vxdisk} list ]:" 
	${vxdisk} list 

	${E} "++++++++++++++++++++[ ${vxdg} list ]:" 
	${vxdg} list 

	${E} "++++++++++++++++++++[ ${vxdctl} -c mode ]:" 
	${vxdctl} -c mode 

	for VXGroup in `${vxdg} -q list  |cut -d' ' -f1 `
	do
	  $E ++++++++++++++++++++ [ ${vxinfo} -g ${VXGroup} ]
	  ${vxinfo} -g ${VXGroup}
	done

	${E} "++++++++++++++++++++[ ${vxprint} ]:" 
	${vxprint} 
	) > ${dest_dir}/vxdata.txt  2>&1
fi

# VxVM (vxfs) specific.
# This data is very large, and not normally useful for debug
#
#vxvm="/etc/vx"
#if [ -d "${vxvm}" ]
#then
#    ${E} "Capture VxVM files"
#    ${mkdir} -p ${dest_dir}/${vxvm}
#    ${cp_r} ${vxvm} ${dest_dir}/ 2>/dev/null
#fi

# Obtain SDS data, if possible and if any.
# Set SDS commands to /usr/sbin, fall back to /usr/opt/SUNWmd
SUNWmd=/usr/sbin/
metadb="${SUNWmd}/metadb"
test -x ${metadb} || SUNWmd=/usr/opt/SUNWmd/sbin/
metadb="${SUNWmd}/metadb"
metaset="${SUNWmd}/metaset"
metastat="${SUNWmd}/metastat"

if [ -x "${nawk}" -a -x "${metadb}" -a -x "${metaset}" -a "${metastat}" ]
then
   $E "Capture SUNWmd volume information"
   (
   $E "++++++++++++++++++++[ ${metaset} ]:" 
   ${metaset} 
   $E "++++++++++++++++++++[ ${metadb} ]:" 
   ${metadb} 
   $E "++++++++++++++++++++[ ${metastat} -p ]:" 
   ${metastat} -p 
   $E "++++++++++++++++++++[ ${metastat} ]:" 
   ${metastat} 
   for ds in `${metaset} | ${nawk} '/^Set name =/{sub(",","",$0); print $4}'`
   do
      $E "++++++++++++++++++++[ ${metadb} -s ${ds} ]:" 
      ${metadb} -s ${ds} 
      $E "++++++++++++++++++++[ ${metastat} -s ${ds} -p ]:" 
      ${metastat} -p -s ${ds} 
      $E "++++++++++++++++++++[ ${metastat} -s ${ds} ]:" 
      ${metastat} -s ${ds} 
   done
   ) > ${dest_dir}/SUNWmd_data.txt  2>&1
fi

# Copy SDS (ODS) specific files.
# This data is very large, and not normally useful for debug
#sds="/etc/opt/SUNWmd"
#if [ -d "${sds}" ]; then
#    ${E} "Capture Solstice DiskSuite files"
#    parent_dir=`${dirname} ${sds}`
#    child_dir=`${basename} ${sds}`
#    (cd ${parent_dir}; ${tar} -cf - ./${child_dir}) | \
#        (cd ${dest_dir}; ${tar} -xf -)
#fi

zoneadm=/usr/sbin/zoneadm
zonecfg=/usr/sbin/zonecfg
ZoneDir=/etc/zones
zonename=/sbin/zonename
if [ -d ${ZoneDir} ]
then
	
	${E} "Capture zone configuration"

	${mkdir} -p ${dest_dir}/${ZoneDir} &&
	    ${cp_r} -f ${ZoneDir}/* ${dest_dir}/${ZoneDir} 2> /dev/null
	
   (	${E} "++++++++++++++++++++[ ${zonename}  ]"
	${zonename}
	
   	${E} "++++++++++++++++++++[ ${df} -kZ ]"
	df -kZ
	
	${E} "++++++++++++++++++++[ ${zoneadm} list -cv ]"
	
	${zoneadm} list -cv
	
	for Zones in `${zoneadm} list -c | ${grep} -v global`
	do
		${E} "++++++++++++++++++++[ ${zonecfg} -z ${Zones} info ]"
		${zonecfg} -z ${Zones} info
		${zonecfg} -z ${Zones} export -f ${zcfg}/zonecfg-${Zones}.txt
	done
   ) > ${dest_dir}/zone-config.txt
fi

zpool=/usr/sbin/zpool
zfs=/usr/sbin/zfs
if [ -x ${zpool} ]
then
	${E} "Capture zpool information"
	for ZP in upgrade list import status
	do
	    ${E} "++++++++++++++++++++[ ${zpool} ${ZP} ] "
		${zpool} ${ZP}
	done > ${dest_dir}/zpool.txt
	for ZF in list "get all"
	do
	    ${E} "++++++++++++++++++++[ ${zfs} ${ZF} ] "
		${zfs} ${ZF}
	done >> ${dest_dir}/zpool.txt 2>&1
fi
	
# If this is a Sun Cluster, capture some data
Cluster=/usr/cluster/bin
if [ -x "${Cluster}/scstat" ]
then
	
    ${E} "Capture Sun Cluster information"

    for SC in "scstat" "scstat -D" "scdidadm -L" "scinstall -pv" "scconf -pv" "scrgadm -p"
    do
	${E} "++++++++++++++++++++[ ${SC} ] "
	${Cluster}/${SC}
    done > ${dest_dir}/Sun_Cluster.txt 2>&1
fi

# If this is a Veritas Cluster, capture some data
hastatus=/opt/VRTS/bin/hastatus
cfscluster=/opt/VRTS/bin/cfscluster
cfsdgadm=/opt/VRTS/bin/cfsdgadm
cfsmntadm=/opt/VRTS/bin/cfsmntadm
if [ -x ${hastatus} ]
then
	${E} "Capture Solaris Veritas Cluster Manager status"
	(
	${E} "++++++++++++++++++++[ ${hastatus} -sum ]"
	${hastatus} -sum
	if [ -x ${cfscluster} ]
	then
		${E} "++++++++++++++++++++[ ${cfscluster} status ]"
		${cfscluster} status
	fi
	if [ -x ${cfsdgadm} ]
	then
		${E} "++++++++++++++++++++[ ${cfsdgadm} display -v ]"
		${cfsdgadm} display -v
	fi
	if [ -x ${cfsmntadm} ]
	then
		${E} "++++++++++++++++++++[ ${cfsmntadm} display -v ]"
		${cfsmntadm} display -v
	fi
	${E} "++++++++++++++++++++[ ${vxdisk} list | ${grep} share ]"
	${vxdisk} list | ${grep} share
	) > ${dest_dir}/VRTS_Cluster.txt 2>&1
fi

${E} "Capture software installations"
${pkginfo} -l > ${dest_dir}/pkginfo.txt

${E} "Capture all of the netstat arguments individually"
for netstats in s rn pn dn i in m an v s
do
    ${E} "++++++++++++++++++++[ ${netstat} -${netstats} ] "
	${netstat} -${netstats}
done > ${dest_dir}/netstat.txt 2>&1

${E} "Capture network tuning and routing"
for Module in tcp ip udp `ifconfig -a |${grep} "^[a-z]"|
	${cut} -d: -f1|${tr} -d "[0-9]"`
do
  ${E} +++++++ ${ndd} /dev/${Module} Param
  for Param in `${ndd} /dev/${Module} \? |
	${cut} -d' ' -f1|
	${egrep} -vi stats\|hash\|obsolete`
  do
	${E} $Param  `${ndd} /dev/${Module} $Param ` 
  done | ${cut} -c1-70
done > ${dest_dir}/net_tune.txt 2>&1

# Generate the data file.
#
# Note: The use of "check_executable ${command}" will work when
#       "${command}" has the form "<command> <flags>".  This usage
#       could give somewhat misleading information in some cases,
#       for example, "/bin/echo p | crash".
#
${E} "Generating system data "

${E} ' debugcapture (%VERSION%.%BUILDNUM%) for Solaris
 $Date: 2012/02/13 22:12:23 $ ' > ${data_file}
for command in ${data_commands}
do
    eval execute="${command}"
    ${E} "++++++++++++++++++++[ ${execute} ]:"
    result=`check_executable ${execute} 2>&1`
    if [ -z "${result}" ]; then
        eval ${execute} 
    else
        ${E} "${result}" 
    fi
    ${E} 
done >> ${data_file}
ulimit -a >> ${data_file}  2>&1

######################################################################
# generic system survey down to here.
# perform Replicator specific checks, then TDMF, each as available
######################################################################

${E} "
######################################################################
# start of IP-migration specific tasks
######################################################################
"

PKGNM="SFTKdtc"
SWNM="DTC"
install_dir=/opt/${PKGNM}
dtcbindir=${install_dir}/bin
dtccfgbase=/etc/opt/${PKGNM}
dtccfgdir=${dtccfgbase}
dtcvardir=/var/opt/${PKGNM}
dtcdrvdir=/usr/kernel/drv/dtc

if [ -d ${dtcvardir} ]
then
	mkdir -p ${dest_dir}/${dtcvardir} &&
	    ${cp_r} -f ${dtcvardir}/* ${dest_dir}/${dtcvardir} 2> /dev/null
fi
  
${mkdir} ${dest_dir}/tmp &&
      ${cp} -pf /tmp/in.???.log ${dest_dir}/tmp 2> /dev/null

# do more only if we are installed.

if [ -x ${dtcbindir}/dtcinfo ]
then

  ${E} "Gathering directory listings"
  ${ls} -laRF ${install_dir} >${dest_dir}/ls--dtcinstall_dir.txt
  ${ls} -laRF  ${dtccfgbase} >${dest_dir}/ls--dtccfgdir.txt
  ${ls} -laRF  ${dtcvardir} >${dest_dir}/ls--dtcvardir.txt
  ${ls} -laRF  ${dtcdrvdir} >${dest_dir}/ls--dtcdrvdir.txt
  
  ${E} "Capture $PKGNM files"
  mkdir -p ${dest_dir}/${dtccfgbase} &&
    ${cp_r} -f ${dtccfgbase}/* ${dest_dir}/${dtccfgbase}/	2>/dev/null

  mkdir -p ${dest_dir}/${dtcdrvdir} &&
    ${cp_r} -f ${dtcdrvdir}* ${dest_dir}/${dtcdrvdir}/	2>/dev/null

  ${E} "Verifying dtc binaries"
  ${E} dtcinfo -v >  ${dest_dir}/bin-info-${PKGNM}.txt
  ${dtcbindir}/dtcinfo -v >> ${dest_dir}/bin-info-${PKGNM}.txt
  for file in ${dtcbindir}/* ${dtcdrvdir}/dtc* 
  do
    if [ -f "${file}" ]
    then
      ${E} "----------" 
      ${ls} -laF ${file} 
      ${filetype} ${file} 
      ${sum} ${file} 
      ${strings} ${file} | ${grep} Version 
    fi
  done >> ${dest_dir}/bin-info-${PKGNM}.txt
  
  ${E} "Verifying ${SWNM} installation"
  ${pkgchk} ${PKGNM} > ${dest_dir}/pkgchk-${SWNM}.txt 2>&1

  ${E} "Capture license key validation information"
  ${E} "Capture the output of dtcinfo"
  (
  $dtcbindir/dtcinfo -v
  $dtcbindir/dtclicinfo
  $dtcbindir/dtchostinfo
  $dtcbindir/dtcinfo -a
  ) > ${dest_dir}/dtcinfo.txt 2>&1

  ${E} "Capture Pstore(s) main headers and groups and devices structures"
  $dtcbindir/dtcinfo -a -s > ${dest_dir}/dtc_pstore_info.txt 2>&1

  ${E} "Capture tunable parameters of ip migration groups"
  if [ -f $dtccfgdir/p[0-9][0-9][0-9].cfg ]
  then
    for cfgFile in $dtccfgdir/p[0-9][0-9][0-9].cfg 
    do
      tmpStr=`${basename} $cfgFile | ${sed} "s/p//" | ${sed} "s/.cfg//"`
      ${E} "---  IP-migration Group ${tmpStr} ---"
      ${dtcbindir}/dtcset -g ${tmpStr}
      ${E} ""
    done > ${dest_dir}/dtcset.txt 2> /dev/null
  fi
  
  Journals=`${grep} -h JOURNAL: $dtccfgdir/s[0-9][0-9][0-9].cfg 2>/dev/null |
    	 ${sed} -e 's/JOURNAL://'|${sort} -u`
  if [ -n "${Journals}" ]
  then
    ${E} "Verify Journal Space"
    (
    ${E} Journals=${Journals} 
    ${E} ${df} ${Journals}
    ${df} ${Journals}
    ${E} ${ls} -l ${Journals}
    ${ls} -l ${Journals}
    ) > ${dest_dir}/dtcJournals.txt 2>&1
  fi
  
  PINGROUTE=0
  for cmds in $cut $ping $sort $tr 
  do
  	test -x $cmds || PINGROUTE=1
  done
  
  if [ "$PINGROUTE" = 1 ]
  then
    ${E} "Cannot check ping"
  else
    PingPrefix="-s"
    PingSuffix="50 10"

    ${E} "Checking connectivity to Mobility hosts"
    ${grep} HOST $dtccfgdir/?[0-9][0-9][0-9].cfg > ${dest_dir}/ping.txt 2>&1
    HOSTS=`${grep} -h HOST $dtccfgdir/?[0-9][0-9][0-9].cfg 2>/dev/null |
    	 ${sed} -e 's/HOST://'| ${tr} -d " \t" |${sort} -u`
    if [ -n "${HOSTS}" ]
    then
      ${E} ${HOSTS}
      for TARGHOST in $HOSTS
      do
        ${E} "++++++++++++++++++++[ $TARGHOST ]:" 
        ${E} ${ping} ${PingPrefix} $TARGHOST ${PingSuffix}
        ${ping} ${PingPrefix} $TARGHOST ${PingSuffix} 2>&1 
      done >>${dest_dir}/ping.txt
    else
      ${E} "No Mobility hosts defined"
      ${E} "No Mobility hosts defined" > ${dest_dir}/ping.txt
    fi
  fi

else
	${E} SFTKdtc is not installed.
fi	# -x ${dtcbindir}/dtcinfo 

######################################################################
# end of IP-migration specific tasks
######################################################################


${E} "
######################################################################
# start of tdmf specific tasks
######################################################################
"
PKGNM="SFTKtdmf"
SWNM=${PKGNM}
install_dir=/opt/${PKGNM}
tdmfbindir=${install_dir}/bin
tdmfcfgdir=/etc/opt/${PKGNM}
tdmfvardir=/var/opt/${PKGNM}
tdmfdrvdir=""
tdmf=${tdmfbindir}/tdmf

if [ -d $tdmfvardir ]
then
  mkdir -p ${dest_dir}/${tdmfvardir} &&
    ${cp_r} -f ${tdmfvardir}/* ${dest_dir}/${tdmfvardir}	2>/dev/null
fi

if [ -x ${tdmf} ]
then
# do more only if we are installed.

  ${E} "Capture tdmf specific info"

  ${tdmf} lic        > ${dest_dir}/tdmflicinfo.txt 2>&1
  ${tdmf} set        > ${dest_dir}/tdmfset.txt 2>&1
  ${tdmf} status -l  > ${dest_dir}/tdmfstatus.txt 2>&1
  ${tdmf} dbdump     > ${dest_dir}/tdmfdbdump.txt 2>&1
  ${tdmf} scrdump -a > ${dest_dir}/tdmfscrdump.txt 2>&1

  mkdir -p ${dest_dir}/${tdmfcfgdir} &&
    ${cp_r} -f ${tdmfcfgdir}/* ${dest_dir}/${tdmfcfgdir}/	2>/dev/null

  test -f /etc/tdmf/lib/tdmflparid.cfg && 
    mkdir -p ${dest_dir}/etc/tdmf/lib/ &&
      ${cp_r} -f /etc/tdmf/lib/tdmflparid.cfg ${dest_dir}/etc/tdmf/lib/	2>/dev/null

  (
   ${E} "++++++++++++++++++++[ tdmf version ]:" 
   ${tdmf} version 
   for execute in ALLVMGROUPS ALLVMVOLUMES ALLMIGGROUPS ALLMIGVOLUMES 
   do
   	${E} "++++++++++++++++++++[ tdmf list +${execute} ]:" 
   	${tdmf} list +${execute}
   done 
  ) > ${dest_dir}/tdmfinfo.txt 2>&1
  
  ${ls} -laRF ${install_dir} >${dest_dir}/ls--tdmfinstall_dir.txt
  ${ls} -laRF ${tdmfvardir} >${dest_dir}/ls--tdmfvardir.txt
  ${ls} -laRF  ${tdmfcfgdir} >${dest_dir}/ls--tdmfcfgdir.txt
  
  ${E} "Verifying binaries"
  
  ${tdmf} version > ${dest_dir}/bin-info-${PKGNM}.txt
  for file in ${tdmfbindir}/* ; do
    if [ -f "${file}" ]
    then
      ${E} "----------" 
      ${ls} -laF ${file} 
      ${filetype} ${file} 
      ${sum} ${file} 
      ${strings} ${file} | ${grep} Version 
    fi
  done >> ${dest_dir}/bin-info-${PKGNM}.txt
  
  ${E} "Verifying ${SWNM} installation"
  ${pkgchk} ${PKGNM} > ${dest_dir}/pkgchk-${SWNM}.txt 2>&1

else
	${E} SFTKtdmf is not installed.
fi	# -x ${tdmf} 

######################################################################
# end of tdmf specific tasks
######################################################################

${E} "Making the archive"
(
    cd ${work_dir}
    ${tar} -cf - ./${archive} 2>/dev/null | ${compress} > ${archive}.tar.Z &&
    ${rm} -rf ${archive} ${archive}.tar 
    ${chmod} 600 ${archive}.tar.Z
)

${E} "Done:
-----"
${ls} -l ${work_dir}/${archive}.tar.Z

exit 0

