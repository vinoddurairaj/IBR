#!/bin/sh

LANG=C
export LANG
######################################################################
# Program:
# --------
# debugcapture (%VERSION%) for Linux
#
# LICENSED MATERIALS / PROPERTY OF IBM
# %PRODUCTNAME% version %VERSION%
# (c) Copyright %COMPANYNAME%  %COPYRIGHTYEAR 2001%.  All Rights Reserved.
# The source code for this program is not published or otherwise
# divested of its trade secrets, irrespective of what has been
# deposited with the U.S. Copyright Office.
# US Government Users Restricted Rights - Use, duplication or
# disclosure restricted by GSA ADP Schedule Contract with %COMPANYNAME%
#
#
# $RCSfile: debugcapture.sh.Linux,v $
# $Revision: 1.28 $
# $Date: 2014/10/15 20:10:05 $
#
# Usage:
# ------
# One simply executes the program, for example,
#
#       nodename1# debugcapture
#
# Description:
# ------------
# This program will collect system, TDMF, TDMF-IP, and Replicator 
# configuration and state information.
#

# Use built-in "echo"
E="echo"

id="/usr/bin/id"
if [ `${id} -u` != 0 ]; then
    ${E} "Error: `${id}`
  One must be root." >&2
    exit 1
fi

if [ -z "$work_dir" ]
then
	work_dir="/var/tmp"
	if [ -z "$1" ]
	then
		${E} "
The working directory is \"${work_dir}\".
You may specify a directory for workspace and final output.
abort this script (ctrl-c) and specify a different directory if desired
	$0 work_dir
"
	/bin/sleep 5
	else
		work_dir="$1"
	fi
fi

#
# Define "check_executable" and "verify_executable".
#
check_executable() {
    if [ ! -x "${1}" ]; then
        ${E} "Warning: unable to find an executable \"${1}\"." >&2
    fi
}

verify_executable() {
    if [ ! -x "${1}" ]; then
        ${E} "Error: unable to find a required command \"${1}\"." >&2
        exit 1
    fi
}

#
# Verify executables.
#
# Set up command variables to be absolute pathnames.
awk="/bin/awk"
basename="/bin/basename"
cat="/bin/cat"
chmod="/bin/chmod"
cksum="/usr/bin/cksum"
cp="/bin/cp"
cpio="/bin/cpio"
cp_r="/bin/cp -r -p"
crash="/sbin/lcrash"
date="/bin/date"
df="/bin/df"
dmesg="/bin/dmesg"
eeprom="/etc/lilo.conf.anaconda"
false="/bin/false"
fdisk="/sbin/fdisk"
filetype="/usr/bin/file"
find=/usr/bin/find
free="/usr/bin/free"
grep="/bin/grep"
hdparm="/sbin/hdparm"
hostid="/usr/bin/hostid"
ifconfig="/sbin/ifconfig"
iostat=/usr/bin/iostat
ipcs="/usr/bin/ipcs"
ls="/bin/ls"
lsmod=/sbin/lsmod
lspci=/sbin/lspci
lspnp=/sbin/lspnp
# Redhat has /sbin, SuSE has /usr/sbin
lsusb=/sbin/lsusb
 test -x ${lsusb} || lsusb=/usr/sbin/lsusb
parted="/sbin/parted"
 test -x ${parted} || parted=/usr/sbin/parted
mkdir="/bin/mkdir"
mount="/bin/mount"
mpstat=/usr/bin/mpstat
netstat="/bin/netstat"
ping=/bin/ping
prtvtoc="/usr/sbin/prtvtoc"
ps="/bin/ps"
rm="/bin/rm"
rpm="/bin/rpm"
sar=/usr/bin/sar
sed="/bin/sed"
service="/sbin/service"
sort=/bin/sort
strings="/usr/bin/strings"
sysctl="/sbin/sysctl"
tail="/usr/bin/tail"
tar="/bin/tar"
tr=/usr/bin/tr
true="/bin/true"
uname="/bin/uname"
uptime=/usr/bin/uptime
vmstat=/usr/bin/vmstat
who=/usr/bin/who
xargs=/usr/bin/xargs
if [ -x /bin/cut ]
then
	cut=/bin/cut
else 
	cut=/usr/bin/cut
fi


# Required commands are tested here.
# Commands not tested fail harmlessly if missing.
req_commands="
    ${awk}
    ${cat}
    ${chmod}
    ${compress}
    ${cp}
    ${cpio}
    ${grep}
    ${id}
    ${ls}
    ${mkdir}
    ${rpm}
    ${strings}
    ${cksum}
    ${tar}
    ${uname}
"
for command in ${req_commands}
do
    verify_executable ${command}
done

# Check the suitability of "${work_dir}".

if   [ ! -d "${work_dir}" ]; then
    ${E} "Error: \"${work_dir}\" is not a directory.
The variable \"work_dir\" is not set correctly." >&2
    exit 1
else
    ${E} "The working directory is \"${work_dir}\"."
fi

#
# Display an informational message.
#
######################################################################
${E} "
This program will collect system and Replicator/TDMF/TDMF-IP
diagnostic information.
"
######################################################################

command00="${date}"
command01="${uname} -a"
command02="${cat} /etc/*-release"
command03="${hostid}"
command04="${cat} /etc/motd"
command05="${df} -k"
command06="${mount} -l"
command07="${free} -o -t"
command08="${iostat}"
command09="${vmstat}"
command10="${mpstat} -P ALL"
command11="${ifconfig} -a"
command12="${ipcs} -a"

data_commands='
    ${command00}
    ${command01}
    ${command02}
    ${command03}
    ${command04}
    ${command05}
    ${command06}
    ${command07}
    ${command08}
    ${command09}
    ${command10}
    ${command11}
    ${command12}
    '
#
# Set up destination directory and file names.
#
archive=`${uname} -n`.`${date} +\%Y\%m\%d-\%H\%M`
dest_dir="${work_dir}/${archive}"
data_file="${dest_dir}/misc_info.txt"

#
# Set up destination directory.
#
(
    cd ${work_dir}
	${rm} -rf ${archive} ${archive}.tar ${archive}.tgz
)

${mkdir} ${dest_dir}; ${chmod} 700 ${dest_dir}

#
# Define cleanup function and install interrupt handler
#
cleanup() {
(
    cd ${work_dir}
	${rm} -rf ${archive} ${archive}.tar ${archive}.tgz
)
exit 1
}

trap cleanup 1 2 3 4 10 15

#
# Copy OS specific files.
#


files="
/boot/config* 
/boot/kernel.h
/etc/fstab*
/etc/host*
/etc/init.d/SFTK*
/etc/inittab
/etc/mod*conf*
/etc/mult*conf*
/etc/rc*
/etc/*-release
/etc/resolv.conf
/etc/rpc
/etc/services
/etc/lvm/archive
/etc/sysconfig/hwconf
/etc/sysconfig/network
/etc/sysconfig/network-scripts/ifcfg-*
/etc/sysctl.conf
/etc/syslog.conf
"

${E} "Copying system config files"
( 
  test -n "${files}" && ${find} ${files} | ${cpio} -pdum ${dest_dir}/
) 2> /dev/null

if [ -f /etc/syslog.conf ]
then
  ${E} Copying syslog files
  files=`awk '$1 !~ /^#/{ sub("*","",$NF); sub("^-","",$NF); print $NF }' /etc/syslog.conf`

  test -n "${files}" && files=`echo ${files} |
	${xargs} ${filetype} |${grep} text|${cut} -d: -f1`
  test -n "${files}" && ${ls} ${files} | ${cpio} -pdum ${dest_dir}/

fi

${E} "Capture /proc files of interest"
files="
/proc/cpuinfo
/proc/devices
/proc/filesystems
/proc/interrupts
/proc/ioports
/proc/kallsyms
/proc/ksyms
/proc/locks
/proc/meminfo
/proc/modules
/proc/partitions
/proc/pci
/proc/slabinfo
/proc/stat
/proc/swaps
/proc/version
"
${mkdir} -p ${dest_dir}/proc/
${cp} -pa ${files} ${dest_dir}/proc 2>/dev/null

${E} "Copying /var/log/* "
${mkdir} -p ${dest_dir}/var/
${cp_r} -p /var/log ${dest_dir}/var/	2>/dev/null
${rm} -f ${dest_dir}/var/log/lastlog	# too big, not worthwhile
${rm} -rf ${dest_dir}/var/log/sa	# too big, not worthwhile

${dmesg} > ${dest_dir}/dmesg.txt 2>&1

${E} "Capture disk information"

if [ -x ${fdisk} ]
then
 ${E} "  fdisk"
 for DiskName in \
  /dev/[h,s]d[a-z] \
  /dev/[h,s]d[a-z][a-z] \
  /dev/dasd[a-z] \
  /dev/dasd[a-z][a-z] 
 do 
  if [ -b ${DiskName} ]
  then
    ${E} +++ fdisk -l ${DiskName}
    ${fdisk} -l ${DiskName}
  fi
 done > ${dest_dir}/fdisk-l.txt 2>&1
fi

if [ -x ${parted} ]
then
 ${E} "  parted"
 for DiskName in \
  /dev/[h,s]d[a-z] \
  /dev/[h,s]d[a-z][a-z] \
  /dev/dasd[a-z] \
  /dev/dasd[a-z][a-z] 
 do 
  if [ -b ${DiskName} ]
  then
    ${E} +++ parted ${DiskName} print
	# Ignore geometry errors.
    ${E} "I" | parted ${DiskName} print
  fi
 done > ${dest_dir}/disk-parted.txt 2>&1
fi

hdparm=dont-run-hdparm	# too much time, no value
if [ -x ${hdparm} ]
then
 ${E} "  hdparm (15 seconds per physical disk)"
 mkdir -p ${dest_dir}/hdparm/
 for DiskName in \
  /dev/[h,s]d[a-z] \
  /dev/[h,s]d[a-z][a-z] \
  /dev/dasd[a-z] \
  /dev/dasd[a-z][a-z] 
 do
   if [ -b ${DiskName} ]
   then
	VOLFILE="${dest_dir}/hdparm/`basename ${DiskName}`-info.txt" 
	${E} "++++++++++++++++++++[ ${DiskName} ]:" > $VOLFILE 2>&1
	for parm in a c d g k m n r u i I t T
	do
		${E} "+++++++++++[ hdparm ${parm} ]:" 
		${hdparm} -${parm} ${DiskName} 
	done >> $VOLFILE 2>&1
   fi
 done
fi

${E} "Capture native LVM information"

vgdisplay="/usr/sbin/vgdisplay"
lvdisplay="/usr/sbin/lvdisplay"
pvdisplay="/usr/sbin/pvdisplay"
pvscan=/sbin/pvscan
VOLFILE="${dest_dir}/volume_group_info.txt"
if [ -x "${vgdisplay}" -a -x "${lvdisplay}" -a -x "${pvdisplay}" ]
then
  ${E} Obtain Logical Group Data

  ${E} "++++++++++++++++++++[ ${vgdisplay} ${lv} ]:" > $VOLFILE
  ${vgdisplay} -v >> $VOLFILE 2>&1

  ${E} Obtain Logical Volume Data
  lvs=`${vgdisplay} -v 2> /dev/null | ${awk} '$0 ~ /LV Name/ {print $3}'`
  for lv in ${lvs}; do
    ${E} "++++++++++++++++++++[ ${lvdisplay} ${lv} ]:"
    ${lvdisplay} ${lv}  2> /dev/null
  done  >> $VOLFILE

  ${E} Obtain Physical Volume Data
  if [ -x ${pvscan} ]
  then
    ${E} "++++++++++++++++++++[ ${pvscan} ]:" >> $VOLFILE
    ${pvscan} >> $VOLFILE 2>&1
  fi

  pvs=`${vgdisplay} -v 2> /dev/null | ${awk} '$0 ~ /PV Name/ {print $3}'`
  for pv in ${pvs}; do
    ${E} "++++++++++++++++++++[ ${pvdisplay} ${pv} ]:" 
    ${pvdisplay} ${pv}  2> /dev/null
  done  >> $VOLFILE
fi


# VxVM (vxfs) specific.
# This data is very large, and not normally useful for debug
#
#vxvm="/etc/vx"
#if [ -d "${vxvm}" ]
#then
#    ${E} "Copying VxVM files "
#    ${mkdir} -p ${dest_dir}/${vxvm}
#    ${cp_r} -p ${vxvm} ${dest_dir}/
#fi

vxdg="/usr/sbin/vxdg"
vxdisk="/usr/sbin/vxdisk"
vxinfo="/usr/sbin/vxinfo"
vxprint="/usr/sbin/vxprint"


if [ -x "${vxdg}" -a -x "${vxprint}" ]; then
    ${E} "Capture Veritas volume group and volume definitions"
    (
	${E} "++++++++++++++++++++[ ${vxdisk} list ]:" 
	${vxdisk} list 

	${E} "++++++++++++++++++++[ ${vxdg} list ]:" 
	${vxdg} list 

	for VXGroup in `${vxdg} -q list  |cut -d' ' -f1 `
	do
	  $E ++++++++++++++++++++ [ ${vxinfo} -g ${VXGroup} ]
	  ${vxinfo} -g ${VXGroup}
	done

	${E} "++++++++++++++++++++[ ${vxprint} ]:" 
	${vxprint} 
	) > ${dest_dir}/vxdata.txt  2>&1
fi

${ls} --full-time -aRF /etc/init.d /etc/rc* >${dest_dir}/ls--rc.txt
${ls} --full-time -aRF /dev >${dest_dir}/ls--dev.txt
${ls} --full-time -aRF /var/crash >${dest_dir}/ls--var_crash.txt 2>&1

${E} "Capture running processes and services"
${E} "++++++++++++++++++++[ ${who} -b ]:" > ${dest_dir}/ps-output.txt
${who} -b  >> ${dest_dir}/ps-output.txt
${E} "++++++++++++++++++++[ ${uptime} ]:" >> ${dest_dir}/ps-output.txt
${uptime} >> ${dest_dir}/ps-output.txt
${E} "++++++++++++++++++++[ ${ps} -el ]:" >> ${dest_dir}/ps-output.txt
${ps} -el >>${dest_dir}/ps-output.txt
${E} "++++++++++++++++++++[ ${ps} -ef ]:" >> ${dest_dir}/ps-output.txt
${ps} -ef >>${dest_dir}/ps-output.txt

${E} "++++++++++++++++++++[ ${service} --status-all ]:" > ${dest_dir}/service-status.txt
${service} --status-all >> ${dest_dir}/service-status.txt 2>&1

if [ -x ${sar} ]
then
  ${E} "Capture system activity report"
  ${E} "++++++++++++++++++++[ ${sar} -du 5 1 ]:" > ${dest_dir}/sar-output.txt
  ${sar} -du 5 1 >> ${dest_dir}/sar-output.txt 2>&1
else
	${E} ${sar} not found, sysstat rpm might not be installed
	${E} ${sar} not found, sysstat rpm might not be installed > ${dest_dir}/sar-output.txt
fi

${E} "Capture rpm query all list"
# sorted by install date, but no architecture information
${rpm} --query --all --last > ${dest_dir}/rpm-query.txt
# architecture information
${rpm} --query --all --queryformat "%{name}-%{version}-%{release}.%{arch}\n" >> ${dest_dir}/rpm-query.txt

${E} "Capture kernel modules list"
${sysctl} -a > ${dest_dir}/kernel-sysctl.txt 2>&1
${lsmod}    > ${dest_dir}/lsmod.txt 2>&1

${E} "Checking /boot files"
( ${ls} --full-time -aRF /boot/ 
${find} /boot/ -exec ${filetype} {} \; 
${find} /boot/ -exec ${cksum} {} \; )>${dest_dir}/boot-files.txt 2>&1

${E} "Capture lspnp lspci lsusb list"
${lspnp}    > ${dest_dir}/lspnp.txt 2>&1

${lspci}    > ${dest_dir}/lspci.txt 2>&1
${lspci} -v > ${dest_dir}/lspci-v.txt 2>&1

${lsusb}    > ${dest_dir}/lsusb.txt 2>&1
${lsusb} -v > ${dest_dir}/lsusb-v.txt 2>&1


# Generate the data file.
# Note: The use of "check_executable ${command}" will work when
#       "${command}" has the form "<command> <flags>".  This usage
#       could give somewhat misleading information in some cases,
#       for example, "/bin/echo p | crash".
#
${E} "Capture miscellaneous system data"

${E} ' debugcapture (%VERSION%.%BUILDNUM%) for Linux
 $Date: 2014/10/15 20:10:05 $ ' > ${data_file}
for command in ${data_commands}
do
    eval execute="${command}"
    ${E} "++++++++++++++++++++[ ${execute} ]:" 
    result=`check_executable ${execute} 2>&1`
    if [ -z "${result}" ]; then
        eval ${execute} 
    else
        ${E} "${result}" 
    fi
    ${E} "" 
done >> ${data_file}  2>&1

${E} "++++++++++++++++++++[ ulimit -a ]:" >> ${data_file} 
ulimit -a >> ${data_file}  2>&1

if [ -x ${netstat} ]
then
  ${E} "Capture all of the netstat arguments individually"
  nets_file="${dest_dir}/netstat.txt"
  for netstats in s i in rn vn an en pn on a
  do
      ${E} "++++++++++++++++++++[ ${netstat} -${netstats} ] " 
  	${netstat} -${netstats} 
  done > ${nets_file} 2>&1
fi

######################################################################
# generic system survey down to here.
# perform Replicator specific checks, then TDMF, each as available
######################################################################

${E} "
######################################################################
# start of Replicator specific tasks
######################################################################
"

PKGNM="SFTKdtc"
install_dir=/opt/${PKGNM}
dtcbindir=${install_dir}/bin
dtccfgdir=/etc/opt/${PKGNM}
dtcvardir=/var/opt/${PKGNM}
dtcrundir=/var/run/${PKGNM}
dtcdrvdir=${install_dir}/driver
dtcdrvdir1=${dtccfgdir}/driver


if [ -d ${dtcvardir} ]
then
	${mkdir} -p ${dest_dir}/${dtcvardir} &&
	    ${cp_r} -f ${dtcvardir}/* ${dest_dir}/${dtcvardir}	2>/dev/null
fi

${ls} --full-time -aRF /var/run >${dest_dir}/ls--var_rundir.txt 2>&1
if [ -d ${dtcrundir} ]
then
	${mkdir} -p ${dest_dir}/${dtcrundir} &&
	    ${cp_r} -f ${dtcrundir}/* ${dest_dir}/${dtcrundir}	2>/dev/null
fi

${mkdir} ${dest_dir}/tmp &&
      ${cp} -f -p /tmp/in.???.log ${dest_dir}/tmp 2> /dev/null

# do more only if we are installed.

if [ -x ${dtcbindir}/dtcinfo ]
then

  ${E} "Capture directory listings"
  ${ls} --full-time -aRF ${install_dir} >${dest_dir}/ls--dtcinstall_dir.txt 2>&1
  ${ls} --full-time -aRF  ${dtccfgdir} >${dest_dir}/ls--dtccfgdir.txt 2>&1
  ${ls} --full-time -aRF  ${dtcvardir} >${dest_dir}/ls--dtcvardir.txt 2>&1
  ${ls} --full-time -aRF  ${dtcdrvdir} >${dest_dir}/ls--dtcdrvdir.txt 2>&1
  ${ls} --full-time -aRF  ${dtcdrvdir1} >>${dest_dir}/ls--dtcdrvdir.txt 2>&1
  
  ${E} "Copying $PKGNM files"
  ${mkdir} -p ${dest_dir}/${dtccfgdir} &&
    ${cp_r} -f ${dtccfgdir}/* ${dest_dir}/${dtccfgdir}/	2>/dev/null

  test -d ${dtcdrvdir} && ${mkdir} -p ${dest_dir}/${dtcdrvdir} &&
    ${cp} -f ${dtcdrvdir}/*conf* ${dest_dir}/${dtcdrvdir}/ 2>/dev/null

  test -d ${dtcdrvdir1} && ${mkdir} -p ${dest_dir}/${dtcdrvdir1} &&
    ${cp} -f ${dtcdrvdir1}/*conf* ${dest_dir}/${dtcdrvdir1}/ 2>/dev/null


  ${E} "Checking dtc binaries "
  ${E} dtcinfo -v >  ${dest_dir}/bin-info-${PKGNM}.txt
  ${dtcbindir}/dtcinfo -v >> ${dest_dir}/bin-info-${PKGNM}.txt
  for file in ${dtcbindir}/* ${dtcdrvdir}/*/*
  do
    if [ -f "${file}" ]
    then
      ${E} "----------" 
      ${ls} --full-time -aF ${file} 
      ${filetype} ${file} 
      ${cksum} ${file} 
      ${strings} ${file} | ${grep} Version 
    fi
  done >> ${dest_dir}/bin-info-${PKGNM}.txt
  
  ${E} "Verifying our package installation "

  SWNM=`${rpm} --query --file ${dtcbindir}/dtcinfo`
  ${rpm} --verify ${SWNM} > ${dest_dir}/rpm-verify-${SWNM}.txt 2>&1

  ${E} "Capture license key validation information"
  ${E} "Capture the output of dtcinfo"
  (
  $dtcbindir/dtcinfo -v
  $dtcbindir/dtclicinfo
  $dtcbindir/dtchostinfo
  $dtcbindir/dtcinfo -a
  ) > ${dest_dir}/dtcinfo.txt 2>&1

  ${E} "Capture Pstore(s) main headers and groups and devices structures"
  $dtcbindir/dtcinfo -a -s > ${dest_dir}/dtc_pstore_info.txt 2>&1

  ${E} "Capture tunable parameters of Mobility groups "
  ${ls} $dtccfgdir/p[0-9][0-9][0-9].cfg >/dev/null 2>&1 ; ERC=$?
  if [ "$ERC" = 0 ]
  then
    for cfgFile in $dtccfgdir/p[0-9][0-9][0-9].cfg 
    do
      tmpStr=`${basename} $cfgFile | ${sed} "s/p//" | ${sed} "s/.cfg//"`
      ${E} "---  Mobility Group ${tmpStr} ---"
      ${dtcbindir}/dtcset -g ${tmpStr}
      ${E} ""
    done > ${dest_dir}/dtcset.txt 2>&1
  fi
  
  Journals=`${grep} -h JOURNAL: ${dtccfgdir}/s[0-9][0-9][0-9].cfg 2>/dev/null |
    	 ${sed} -e 's/JOURNAL://'|${sort} -u`
  if [ -n "${Journals}" ]
  then
    ${E} "Verify Journal Space"
    (
    ${E} Journals=${Journals} 
    ${E} ${df} ${Journals}
    ${df} ${Journals}
    ${E} ${ls} -l ${Journals}
    ${ls} -l ${Journals}
    ) > ${dest_dir}/dtcJournals.txt 2>&1
  fi
  
  PingPrefix="-c 10"
  PingSuffix=""
  
  PINGROUTE=0
  for cmds in $ping $sort $tr 
  do
  	test -x $cmds || PINGROUTE=1
  done
  
  if [ "$PINGROUTE" = 1 ]
  then
    ${E} "Cannot check ping"
  else
    ${E} "Checking connectivity to Mobility hosts"
    ${grep} HOST $dtccfgdir/?[0-9][0-9][0-9].cfg > ${dest_dir}/ping.txt 2>&1
    HOSTS=`${grep} -h HOST $dtccfgdir/?[0-9][0-9][0-9].cfg 2>/dev/null |
    	 ${sed} -e 's/HOST://'| ${tr} -d " \t" |${sort} -u`
    if [ -n "${HOSTS}" ]
    then
      ${E} ${HOSTS}
      for TARGHOST in $HOSTS
      do
        ${E} "++++++++++++++++++++[ $TARGHOST ]:" 
        ${E} ${ping} or ${ping}6 ${PingPrefix} $TARGHOST ${PingSuffix}
        ${ping} ${PingPrefix} $TARGHOST ${PingSuffix} 2>&1 ||
        ${ping}6 ${PingPrefix} $TARGHOST ${PingSuffix} 2>&1 
      done >>${dest_dir}/ping.txt
    else
      ${E} "No Mobility hosts defined"
      ${E} "No Mobility hosts defined" > ${dest_dir}/ping.txt
    fi
  fi
else
	${E} SFTKdtc is not installed.
fi	# -x ${dtcbindir}/dtcinfo 

######################################################################
# end of TDMF-IP/Replicator specific tasks
######################################################################


# Make the archive.
#
${E} "######################################################################"
${E} "Making the archive "
(
    cd ${work_dir}
    ${tar} -czf ./${archive}.tgz ./${archive} 2>/dev/null 
    if [ $? -eq 0 ]
    then
      ${rm} -rf ${archive} 
    else
      ${E} error building ${archive}.tgz
    fi
    ${chmod} 600 ${archive}.tgz
)

${ls} -l ${work_dir}/${archive}.tgz

exit 0
