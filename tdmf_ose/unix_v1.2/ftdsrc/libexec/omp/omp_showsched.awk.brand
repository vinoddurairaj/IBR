#!/usr/bin/gawk -f
###############################################################################
#
# LICENSED MATERIALS / PROPERTY OF IBM
#
# Offline Migration Package (OMP)   Version %VERSION%
#
# (c) Copyright %COMPANYNAME%  %COPYRIGHTYEAR 2007%.  All Rights Reserved.
#
# The source code for this program is not published or otherwise
# divested of its trade secrets, irrespective of what has been
# deposited with the U.S. Copyright Office.
#
# US Government Users Restricted Rights - Use, duplication or
# disclosure restricted by GSA ADP Schedule Contract with %COMPANYNAME%
#
# $Id: omp_showsched.awk.brand,v 1.3 2010/01/13 19:37:51 naat0 Exp $
#
# Function: Validate and Generate Configuration Files
#
###############################################################################

function CreateSortPattern( value,   sort_pattern )
{
    sort_pattern=value

    gsub(/[^0-9]+/,"a", sort_pattern)
    gsub(/[0-9]+/,"n", sort_pattern)
    return sort_pattern
}

function PatternCompare( value1, pattern1, value2, pattern2,    p1len, p2len, p1idx, p2idx, p1, p2, compare1, compare2 )
{
    p1len = length(pattern1)
    p2len = length(pattern1)

    if (p1len <= 0 || p2len <= 0)
    {
	if (value1 > value2) return 1
	if (value1 < value2) return -1
	return 0
    }

    p1idx = 1
    p2idx = 1

    while (p1idx <= p1len && p2idx <= p2len)
    {
	p1 = substr( pattern1, p1idx, 1)
	p2 = substr( pattern2, p2idx, 1)
	p1idx++
	p2idx++

	if (p1 == "n" && p2 == "n")
	{
	    if (match( value1, /^[0-9]+/ ))
	    {
		compare1 = substr( value1, RSTART, RLENGTH )
		compare1 += 0
		if (RLENGTH + 1 <= length(value1))
		{
		    value1 = substr( value1, RLENGTH+1 )
		}
		else
		{
		    value1 = ""
		}
	    }
	    if (match( value2, /^[0-9]+/ ))
	    {
		compare2 = substr( value2, RSTART, RLENGTH )
		compare2 += 0
		if (RLENGTH + 1 <= length(value2))
		{
		    value2 = substr( value2, RLENGTH+1 )
		}
		else
		{
		    value2 = ""
		}
	    }

	    if (compare1 - compare2 != 0)
		return compare1 - compare2
	}
	else if (p1 == "a" && p2 == "a")
	{
	    if (match( value1, /^[^0-9]+/ ))
	    {
		compare1 = substr( value1, RSTART, RLENGTH )
		if (RLENGTH + 1 <= length(value1))
		{
		    value1 = substr( value1, RLENGTH+1 )
		}
		else
		{
		    value1 = ""
		}
	    }
	    if (match( value2, /^[^0-9]+/ ))
	    {
		compare2 = substr( value2, RSTART, RLENGTH )
		if (RLENGTH + 1 <= length(value2))
		{
		    value2 = substr( value2, RLENGTH+1 )
		}
		else
		{
		    value2 = ""
		}
	    }
	    if (compare1 > compare2) return 1
	    if (compare1 < compare2) return -1
	}
	else
	{
	    if (value1 > value2) return 1
	    if (value1 < value2) return -1
	    return 0
	}
    }
    if (p1idx <= p1len || p2idx <= p2len)
    {
	if (value1 > value2) return 1
	if (value1 < value2) return -1
    }
    return 0
}

function Compare( Arg, idx1, idx2,   n, value1, value2, pattern1, pattern2, source1, source2, sn1, sn2 )
{
    if (Arg == "MigrationGroup")
    {
	pattern1 = PatternScheduleGroup[idx1]
	value1 = ScheduleGroup[idx1]
	pattern2 = PatternScheduleGroup[idx2]
	value2 = ScheduleGroup[idx2]

	n = PatternCompare( value1, pattern1, value2, pattern2 )
	if (n != 0) return n

	value1 = MigrationGroup[idx1] + 0
	value2 = MigrationGroup[idx2] + 0
	if (value1 > value2) return 1
	if (value1 < value2) return -1

	value1 = DiskOrder[idx1] + 0
	value2 = DiskOrder[idx2] + 0
	if (value1 > value2) return 1
	if (value1 < value2) return -1
    }
    else if (Arg == "ScheduleLun")
    {
	pattern1 = PatternScheduleGroup[idx1]
	value1 = ScheduleGroup[idx1]
	pattern2 = PatternScheduleGroup[idx2]
	value2 = ScheduleGroup[idx2]

	n = PatternCompare( value1, pattern1, value2, pattern2 )
	if (n != 0) return n

	/* compare LUN */
	sn1 = split( SourceLun[idx1], source1, " " )
	sn2 = split( SourceLun[idx2], source2, " " )

	value1 = source1[sn1] + 0 
	value2 = source2[sn2] + 0 

	if (value1 > value2) return 1
	if (value1 < value2) return -1
    }
    else if (Arg == "ScheduleGroup" )
    {
	pattern1 = PatternScheduleGroupOrder[idx1]
	value1   = ScheduleGroupOrder[idx1]
	pattern2 = PatternScheduleGroupOrder[idx2]
	value2   = ScheduleGroupOrder[idx2]
	return PatternCompare( value1, pattern1, value2, pattern2 )
    }
    return 0
}

function SwapPosition(Arg, i,j,   value) 
{
    if (Arg == "MigrationGroup" || Arg == "ScheduleLun")
    {
	value = ScheduleGroup[i]
	ScheduleGroup[i] = ScheduleGroup[j]
	ScheduleGroup[j] = value

	value = PatternScheduleGroup[i]
	PatternScheduleGroup[i] = PatternScheduleGroup[j]
	PatternScheduleGroup[j] = value

	value = MigrationGroup[i]
	MigrationGroup[i] = MigrationGroup[j]
	MigrationGroup[j] = value

	value = SourceLun[i]
	SourceLun[i] = SourceLun[j]
	SourceLun[j] = value

	value = TargetLun[i]
	TargetLun[i] = TargetLun[j]
	TargetLun[j] = value

	value = SourceOsDevice[i]
	SourceOsDevice[i] = SourceOsDevice[j]
	SourceOsDevice[j] = value

	value = TargetOsDevice[i]
	TargetOsDevice[i] = TargetOsDevice[j]
	TargetOsDevice[j] = value

	value = SourceLunSize[i]
	SourceLunSize[i] = SourceLunSize[j]
	SourceLunSize[j] = value

	value = DiskOrder[i]
	DiskOrder[i] = DiskOrder[j]
	DiskOrder[j] = value
    }
    else if (Arg == "ScheduleGroup")
    {
	value = PatternScheduleGroupOrder[i]
	value = ScheduleGroupOrder[i]
	PatternScheduleGroupOrder[i] = PatternScheduleGroupOrder[j]
	ScheduleGroupOrder[i] = ScheduleGroupOrder[j]
	PatternScheduleGroupOrder[j] = value
	ScheduleGroupOrder[j] = value
    }
}

function CreateHeap(Arg, left_item, right_item,   l, k) 
{
    for (l = left_item; (k = 2*l) <= right_item; l = k) 
    {
        if (k < right_item && Compare( Arg, k+1, k ) > 0)
            { k++ }
        if (Compare( Arg, l, k ) < 0)
            { SwapPosition(Arg, k, l ) }
    }
}

function HeapSort(Arg, n,   i) 
{
    for (i = int(n/2); i >= 1; i--)
    {
	CreateHeap( Arg, i, n )
    }
    for (i = n; i > 1; i--) 
    {     
	SwapPosition( Arg, 1, i )
	CreateHeap( Arg, 1, i-1 )
    }
}

function QuickSort(Arg, left_item, right_item,   i,last) 
{
     if (left_item >= right_item)
         return       
     SwapPosition(Arg, left_item, left_item + int((right_item-left_item+1)*rand()))
     last = left_item
     for (i = left_item+1; i <= right_item; i++)
         if (Compare( Arg, i, left_item ) < 0)
             SwapPosition(Arg, ++last, i)
     SwapPosition(Arg, left_item, last)
     QuickSort(Arg, left_item, last-1)
     QuickSort(Arg, last+1, right_item)
}
BEGIN {
    FS=":|==>"
    if (DisplayType == 0)
    {
	DisplayType=15
    }
    ScheduleReport=0
    GroupReport=0
    GroupDetailReport=0
    ScheduleDetailReport=0
    if (DisplayType >= 8)
    {
	ScheduleDetailReport=1
	ScheduleReport=1
	DisplayType -= 8
    }
    if (DisplayType >= 4)
    {
	GroupDetailReport=1
	GroupReport=1
	DisplayType -= 4
    }
    if (DisplayType >= 2)
    {
	GroupReport=1
	DisplayType -= 2
    }
    if (DisplayType >= 1)
    {
	ScheduleReport=1
	DisplayType -= 1
    }

    idx=0
}
$1 ~ /NOTES/ {
    schedule_group=$2
    sub(/^[ \t]+/, "", schedule_group)
    sub(/[ \t]+$/, "", schedule_group)
    migration_group=FILENAME
    sub(/.*\//, "", migration_group)
    sub(/.cfg|.done|.error/, "", migration_group)
    sub(/^p/, "", migration_group)
}

$1 ~  /REMARK/ {
    source_info = $2
    sub(/^[ \t]+/, "", source_info)
    sub(/[ \t]+$/, "", source_info)
    target_info = $3
    sub(/^[ \t]+/, "", target_info)
    sub(/[ \t]+$/, "", target_info)
    if (NF >= 5 && $4 == "SIZEMB")
	source_size_mb = $5
    else
	source_size_mb = 0
    idx++
    ScheduleGroup[idx]=schedule_group
    PatternScheduleGroup[idx]=CreateSortPattern( schedule_group )
    MigrationGroup[idx]=migration_group
    SourceLun[idx]=source_info
    TargetLun[idx]=target_info
    DiskOrder[idx]=idx		# Makes the sort stable
    SourceLunSize[idx]=source_size_mb
    if (schedule_group in LunsPerScheduleGroup)
    {
	LunsPerScheduleGroup[schedule_group]++
    }
    else
    {
	LunsPerScheduleGroup[schedule_group] = 1
	MigGroupsPerScheduleGroup[schedule_group] = 0
	MaxSchedIdx++
	ScheduleGroupOrder[MaxSchedIdx] = schedule_group
	PatternScheduleGroupOrder[MaxSchedIdx] = CreateSortPattern( schedule_group )
    }
    if (migration_group in LunsPerMigrationGroup)
    {
	LunsPerMigrationGroup[migration_group]++
    }
    else
    {
	LunsPerMigrationGroup[migration_group] = 1
	MigGroupsPerScheduleGroup[schedule_group]++
    }
}

$1 ~  /DATA-DISK/ {
    SourceOsDevice[idx] = $2
    sub(/^[ \t]+/, "", SourceOsDevice[idx])
    sub(/[ \t]+$/, "", SourceOsDevice[idx])
}

$1 ~  /MIRROR-DISK/ {
    TargetOsDevice[idx] = $2
    sub(/^[ \t]+/, "", TargetOsDevice[idx])
    sub(/[ \t]+$/, "", TargetOsDevice[idx])
}

END {
    MaxIdx=idx
    first_time=0

    if (ScheduleReport)
    {
	HeapSort( "ScheduleGroup", 1, MaxSchedIdx )
	if (ScheduleDetailReport)
	{
	    QuickSort( "ScheduleLun", 1, MaxIdx )
	}
	for (idx=1; idx <=MaxSchedIdx; idx++)
	{
	    schedule_group = ScheduleGroupOrder[idx]
	    regexp = ":" schedule_group ":"

	    if (FilterGroups != "::" && match(FilterGroups, regexp) <= 0)
	    {
		continue
	    }
	    if (first_time == 0)
	    {
		print "schedule group     migs   luns"
		first_time = 1
	    }

	    printf( "%-17s  %4d  %4d\n", \
		    schedule_group, \
		    MigGroupsPerScheduleGroup[schedule_group], \
		    LunsPerScheduleGroup[schedule_group] )
	    if (ScheduleDetailReport)
	    {
		for (gidx=1; gidx <=MaxIdx; gidx++)
		{
		    if (ScheduleGroup[gidx] == schedule_group)
		    {
			print "    ", SourceLun[gidx], "==>", TargetLun[gidx]
			print "    ", SourceOsDevice[gidx], "==>", TargetOsDevice[gidx]
		    }
		}
	    }
	}
    }
    if (GroupReport)
    {
	QuickSort( "MigrationGroup", 1, MaxIdx )
	LastMigrationGroup=-1

	for (idx=1; idx <=MaxIdx; idx++)
	{
	    schedule_group = ScheduleGroup[idx]
	    regexp = ":" schedule_group ":"
	    if (FilterGroups != "::" && match(FilterGroups, regexp) <= 0)
	    {
		continue
	    }
	    if (first_time < 2)
	    {
		if (first_time > 0) print ""
		print "schedule group     mig  luns"
		first_time += 16
	    }
	    if (LastMigrationGroup != MigrationGroup[idx])
	    {
		LastMigrationGroup = MigrationGroup[idx]
		printf( "%-17s  %03d  %4d\n", ScheduleGroup[idx],
				MigrationGroup[idx],
				LunsPerMigrationGroup[LastMigrationGroup] )
	    }
	    if (GroupDetailReport)
	    {
		print "    ", SourceLun[idx], "==>", TargetLun[idx]
		print "    ", SourceOsDevice[gidx], "==>", TargetOsDevice[gidx]
	    }
	}
    }
}
