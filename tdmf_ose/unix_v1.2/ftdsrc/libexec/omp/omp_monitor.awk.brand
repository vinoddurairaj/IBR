#!/usr/bin/gawk -f
###############################################################################
#
# LICENSED MATERIALS / PROPERTY OF IBM
#
# Offline Migration Package (OMP)   Version %VERSION%
#
# (c) Copyright %COMPANYNAME%  %COPYRIGHTYEAR 2007%.  All Rights Reserved.
#
# The source code for this program is not published or otherwise
# divested of its trade secrets, irrespective of what has been
# deposited with the U.S. Copyright Office.
#
# US Government Users Restricted Rights - Use, duplication or
# disclosure restricted by GSA ADP Schedule Contract with %COMPANYNAME%
#
# $Id: omp_monitor.awk.brand,v 1.3 2008/12/28 10:12:16 naat0 Exp $
#
# Function: Validate and Generate Configuration Files
#
###############################################################################

function PatternCompare( value1, pattern1, value2, pattern2,    p1len, p2len, p1idx, p2idx, p1, p2, compare1, compare2 )
{
    p1len = length(pattern1)
    p2len = length(pattern1)

    if (p1len <= 0 || p2len <= 0)
    {
	if (value1 > value2) return 1
	if (value1 < value2) return -1
	return 0
    }

    p1idx = 1
    p2idx = 1

    while (p1idx <= p1len && p2idx <= p2len)
    {
	p1 = substr( pattern1, p1idx, 1)
	p2 = substr( pattern2, p2idx, 1)
	p1idx++
	p2idx++

	if (p1 == "n" && p2 == "n")
	{
	    if (match( value1, /^[0-9]+/ ))
	    {
		compare1 = substr( value1, RSTART, RLENGTH )
		compare1 += 0
		if (RLENGTH + 1 <= length(value1))
		{
		    value1 = substr( value1, RLENGTH+1 )
		}
		else
		{
		    value1 = ""
		}
	    }
	    if (match( value2, /^[0-9]+/ ))
	    {
		compare2 = substr( value2, RSTART, RLENGTH )
		compare2 += 0
		if (RLENGTH + 1 <= length(value2))
		{
		    value2 = substr( value2, RLENGTH+1 )
		}
		else
		{
		    value2 = ""
		}
	    }

	    if (compare1 - compare2 != 0)
		return compare1 - compare2
	}
	else if (p1 == "a" && p2 == "a")
	{
	    if (match( value1, /^[^0-9]+/ ))
	    {
		compare1 = substr( value1, RSTART, RLENGTH )
		if (RLENGTH + 1 <= length(value1))
		{
		    value1 = substr( value1, RLENGTH+1 )
		}
		else
		{
		    value1 = ""
		}
	    }
	    if (match( value2, /^[^0-9]+/ ))
	    {
		compare2 = substr( value2, RSTART, RLENGTH )
		if (RLENGTH + 1 <= length(value2))
		{
		    value2 = substr( value2, RLENGTH+1 )
		}
		else
		{
		    value2 = ""
		}
	    }
	    if (compare1 > compare2) return 1
	    if (compare1 < compare2) return -1
	}
	else
	{
	    if (value1 > value2) return 1
	    if (value1 < value2) return -1
	    return 0
	}
    }
    if (p1idx <= p1len || p2idx <= p2len)
    {
	if (value1 > value2) return 1
	if (value1 < value2) return -1
    }
    return 0
}

function Compare( Arg, idx1, idx2,   n, value1, value2, pattern1, pattern2, key1, key2 )
{
    if (Arg == "RepGroup")
    {
	pattern1 = SortPtrnRepGroup[idx1]
	value1   = SortDataRepGroup[idx1]
	pattern2 = SortPtrnRepGroup[idx2]
	value2   = SortDataRepGroup[idx2]

	n = split( value1, key1, SUBSEP ) 
	n = split( value2, key2, SUBSEP ) 

	n = PatternCompare( key1[1], pattern1, key2[1], pattern2 )
	if (n != 0) return n

	key1[2] += 0
	key2[2] += 0
	if (key1[2] > key2[2]) return 1
	if (key1[2] < key2[2]) return -1
	return 0
    }
    else if (Arg == "SchedGroup")
    {
	pattern1 = SortPtrnSchedGroup[idx1]
	value1   = SortDataSchedGroup[idx1]
	pattern2 = SortPtrnSchedGroup[idx2]
	value2   = SortDataSchedGroup[idx2]

	return PatternCompare( value1, pattern1, value2, pattern2 )
    }
    return 0
}

function SwapPosition(Arg, i,j,   pattern, value) 
{
    if (Arg == "RepGroup")
    {
	pattern = SortPtrnRepGroup[i]
	value   = SortDataRepGroup[i]
	SortPtrnRepGroup[i] = SortPtrnRepGroup[j]
	SortDataRepGroup[i] = SortDataRepGroup[j]
	SortPtrnRepGroup[j] = pattern
	SortDataRepGroup[j] = value
    }
    else if (Arg == "SchedGroup")
    {
	pattern = SortPtrnSchedGroup[i]
	value   = SortDataSchedGroup[i]
	SortPtrnSchedGroup[i] = SortPtrnSchedGroup[j]
	SortDataSchedGroup[i] = SortDataSchedGroup[j]
	SortPtrnSchedGroup[j] = pattern
	SortDataSchedGroup[j] = value
    }
}

function CreateHeap(Arg, left_item, right_item,   l, k) 
{
    for (l = left_item; (k = 2*l) <= right_item; l = k) 
    {
        if (k < right_item && Compare( Arg, k+1, k ) > 0)
            { k++ }
        if (Compare( Arg, l, k ) < 0)
            { SwapPosition(Arg, k, l ) }
    }
}

function HeapSort(Arg, n,   i) 
{
    for (i = int(n/2); i >= 1; i--)
    {
	CreateHeap( Arg, i, n )
    }
    for (i = n; i > 1; i--) 
    {     
	SwapPosition( Arg, 1, i )
	CreateHeap( Arg, 1, i-1 )
    }
}

function QuickSort(Arg, left_item, right_item,   i,last) 
{
     if (left_item >= right_item)
         return       
     SwapPosition(Arg, left_item, left_item + int((right_item-left_item+1)*rand()))
     last = left_item
     for (i = left_item+1; i <= right_item; i++)
         if (Compare( Arg, i, left_item ) < 0)
             SwapPosition(Arg, ++last, i)
     SwapPosition(Arg, left_item, last)
     QuickSort(Arg, left_item, last-1)
     QuickSort(Arg, last+1, right_item)
}

function set_omp_state( old_state, new_state )
{
    if (old_state == OMP_STATE_UNKNOWN)
    {
	return new_state
    }
    if (old_state == OMP_STATE_ERROR)
    {
	return old_state
    }
    if (old_state == OMP_STATE_DONE)
    {
	if (new_state == OMP_STATE_ERROR || new_state == OMP_STATE_DONE)
	    return new_state
	else
	    return OMP_STATE_COPYING
    }
    if (old_state == OMP_STATE_COPYING)
    {
	if (new_state == OMP_STATE_ERROR)
	    return new_state
	return old_state
    }
    if (old_state == OMP_STATE_STARTED)
    {
	if (new_state == OMP_STATE_ERROR)
	    return new_state
	if (new_state == old_state)
	    return old_state
	return OMP_STATE_COPYING
    }
    return OMP_STATE_ERROR
}

function set_state( old_omp_state, new_rep_state )
{
    if (old_omp_state == OMP_STATE_UNKNOWN)
    {
	return RepToOmpStateMap[new_rep_state]
    }
    if (old_omp_state == OMP_STATE_ERROR)
    {
	return old_omp_state
    }
    if (old_omp_state == OMP_STATE_STARTED)
    {
	return RepToOmpStateMap[new_rep_state]
    }
    if (old_omp_state == OMP_STATE_COPYING)
    {
	if (new_omp_state == REP_STATE_TRACKING || new_omp_state == REP_STATE_BACKFRESH)
	    return RepToOmpStateMap[new_rep_state]
	else
	    return old_omp_state
    }
    if (old_omp_state == OMP_STATE_DONE)
    {
	if (new_rep_state == REP_STATE_PASSTRU)
	    return OMP_STATE_COPYING
	else
	    return RepToOmpStateMap[new_rep_state]
    }
    return OMP_STATE_ERROR
}

function CalculateStatistics(    key, subscript, n, queue, replication_group, schedule_group, disk_idx, max_disk_idx, size, percent, state, actual, effective )
{
    for (key in RepGroup)
    {
	n = split( key, subscript, SUBSEP )
	if (n == 2 && subscript[2] == "queue")
	{
	    queue=RepGroup[key]
	    replication_group=subscript[1]
	    schedule_group=RepGroup[replication_group,"schedgrp"]

	    RepGroupStats[replication_group,"SizeMB"]=0
	    RepGroupStats[replication_group,"PercentDone"]=0
	    RepGroupStats[replication_group,"State"]=OMP_STATE_UNKNOWN
	    RepGroupStats[replication_group,"NetActual"] = 0
	    RepGroupStats[replication_group,"NetEffective"] = 0

	    if (!((schedule_group,queue) in SchedGroupStats))
	    {
		SchedGroupStats[schedule_group,"Wait"] = 0
		SchedGroupStats[schedule_group,"Active"] = 0
		SchedGroupStats[schedule_group,"Done"] = 0
		SchedGroupStats[schedule_group,"Error"] = 0
		SchedGroupStats[schedule_group,"PercentDone"] = 0
		SchedGroupStats[schedule_group,"State"] = OMP_STATE_UNKNOWN
		SchedGroupStats[schedule_group,"MaxRepGroup"] = 0
		SchedGroupStats[schedule_group, "SizeMB"] = 0
	    }

	    SchedGroupStats[schedule_group,queue]++
	    SchedGroupStats[schedule_group,"MaxRepGroup"]++

	    max_disk_idx=RepGroup[replication_group, "MaxDiskIdx"]
	    for (disk_idx = 1; disk_idx <= max_disk_idx; disk_idx++)
	    {
		size = RepDevice[replication_group, disk_idx, "SizeMB"]
		percent = RepDevice[replication_group, disk_idx, "PercentDone"]
		state = RepDevice[replication_group, disk_idx, "State"]
		actual = RepDevice[replication_group, disk_idx, "NetActual"]
		effective = RepDevice[replication_group, disk_idx, "NetEffective"]
		RepGroupStats[replication_group,"SizeMB"] += size
		RepGroupStats[replication_group,"PercentDone"] += percent
		RepGroupStats[replication_group,"State"] = \
		    set_omp_state( RepGroupStats[replication_group,"State"], state )
		RepGroupStats[replication_group,"NetActual"] += actual
		RepGroupStats[replication_group,"NetEffective"] += effective

		SchedGroupStats[schedule_group,"SizeMB"] += size
	    }

	    RepGroupStats[replication_group,"PercentDone"] /= max_disk_idx
	    SchedGroupStats[schedule_group, "PercentDone"] += \
	    	RepGroupStats[replication_group,"PercentDone"] 
	    SchedGroupStats[schedule_group,"State"] = \
		set_omp_state( SchedGroupStats[schedule_group,"State"], \
			       RepGroupStats[replication_group,"State"] )

	}
    }
}

function Format1000XB( value, value_unit,   unit, string )
{
    while (value >= 1000)
    {
	value /= 1000
	value_unit++
    }
    unit = Units[value_unit]
    unit = tolower(substr( unit, 1, 1 )) substr( unit, 2, 1 )
    string = sprintf( "%.2f %s", value, unit )
    sub( /\.00 /, " ", string )
    return string
}

function Format1024XB( value, value_unit,   string )
{
    while (value >= 1024)
    {
	value /= 1024
	value_unit++
    }
    string = sprintf( "%.2f %s", value, Units[value_unit] )
    sub( /\.00 /, " ", string )
    return string
}

function FormatPercentage( value,   string )
{
    string = sprintf( "%.2f", value )
    sub(/\.00$/,"",string)
    return string "%"
}

function CreateSortPattern( value )
{
    gsub(/[^0-9]+/,"a", value)
    gsub(/[0-9]+/,"n", value)
    return value
}

function PrintStatistics(   schedule_group, size, key, n, subscript, percent, queue, max_disk_idx, idx, sched_idx, rep_idx, replication_group, actual, effective, first_time )
{
    first_time = 0
    if (DisplayType % 2 == 1)
    {
	for (sched_idx = 1; sched_idx <= MaxSortSchedIdx; sched_idx++)
	{
	    if (first_time % 16 == 0)
	    {
		print strftime()
		first_time += 1
		print "schedule group      state   progress   size     waiting  active  done  error"
	    }

	    schedule_group = SortDataSchedGroup[sched_idx]
	    SchedGroupStats[schedule_group,"PercentDone"] /= \
		SchedGroupStats[schedule_group,"MaxRepGroup"] 

	    size = Format1024XB( SchedGroupStats[schedule_group,"SizeMB"],  UNITS_MB )
	    percent = FormatPercentage( SchedGroupStats[schedule_group,"PercentDone"] )
	    printf( "%-17s  %-7s %7s  %10s   %4d    %4d    %4d  %4d\n", \
		    schedule_group, SchedGroupStats[schedule_group,"State"], \
		    percent, size, SchedGroupStats[schedule_group,"Wait"], \
		    SchedGroupStats[schedule_group,"Active"], \
		    SchedGroupStats[schedule_group,"Done"], \
		    SchedGroupStats[schedule_group,"Error"] )
	}
	DisplayType -= 1
    }


    if (DisplayType)
    {
	for (rep_idx = 1; rep_idx <= MaxSortRepIdx; rep_idx++)
	{
	    if (first_time == 0)
	    {
		print strftime()
	    }
	    if (first_time < 16)
	    {
		if (first_time > 0) print ""
		first_time += 16
		print "  schedule group   mig    state   progress    size       actual      effect"
	    }
	    key = SortDataRepGroup[rep_idx]
	    n = split( key, subscript, SUBSEP )
	    schedule_group = subscript[1]
	    replication_group = subscript[2]
	    queue=RepGroup[replication_group,"queue"]
	    max_disk_idx=RepGroup[replication_group, "MaxDiskIdx"]

	    size = Format1024XB( RepGroupStats[replication_group,"SizeMB"], UNITS_MB )
	    percent = FormatPercentage( RepGroupStats[replication_group,"PercentDone"] )
	    actual = Format1024XB( RepGroupStats[replication_group,"NetActual"], UNITS_KB )
	    effective = Format1024XB( RepGroupStats[replication_group,"NetEffective"], UNITS_KB )
	    printf( "%-17s  %03d   %-7s  %7s  %10s  %10s  %10s\n", \
		    schedule_group, replication_group, \
		    RepGroupStats[replication_group,"State"], \
		    percent, size, actual, effective )
	    if (DisplayType > 2)
	    {
		if ((replication_group,"Timestamp") in RepGroup)
		{
		    print RepGroup[replication_group,"Timestamp"]
		}
		for (idx = 1; idx <= max_disk_idx; idx++)
		{
		    print "\t" RepDevice[replication_group,idx,"SourceLun"], "==>", RepDevice[replication_group,idx,"TargetLun"]
		}
	    }
	}
    }
    if (first_time == 0)
    {
	print strftime(), "    No migration data is available."
    }
    return 0
}

BEGIN {
    FS=":|==>|\\|\\|"
    REP_STATE_NORMAL=0
    REP_STATE_TRACKING=1
    REP_STATE_PASSTHRU=2
    REP_STATE_REFRESH=3
    REP_STATE_BACKFRESH=4

    OMP_STATE_UNKNOWN="UNKNOWN"
    OMP_STATE_STARTED="READY"
    OMP_STATE_COPYING="COPYING"
    OMP_STATE_ERROR="ERROR"
    OMP_STATE_DONE="DONE"
    RepToOmpStateMap[REP_STATE_NORMAL]=OMP_STATE_COPYING
    RepToOmpStateMap[REP_STATE_TRACKING]=OMP_STATE_ERROR
    RepToOmpStateMap[REP_STATE_PASSTHRU]=OMP_STATE_STARTED
    RepToOmpStateMap[REP_STATE_REFRESH]=OMP_STATE_COPYING
    RepToOmpStateMap[REP_STATE_BACKFRESH]=OMP_STATE_ERROR

    UNITS_B  = 1
    UNITS_KB = 2
    UNITS_MB = 3
    UNITS_GB = 4
    UNITS_TB = 5
    UNITS_PB = 6
    UNITS_EB = 7
    UNITS_ZB = 8
    UNITS_YB = 9

    Units[UNITS_B] = "B "
    Units[UNITS_KB] = "KB"
    Units[UNITS_MB] = "MB"
    Units[UNITS_GB] = "GB"
    Units[UNITS_TB] = "TB"
    Units[UNITS_PB] = "PB"
    Units[UNITS_EB] = "EB"
    Units[UNITS_ZB] = "ZB"
    Units[UNITS_YB] = "YB"

    if (DisplayType <= 0)
    {
	DisplayType = 7
    }

    MaxSortSchedIdx=0
    MaxSortRepIdx=0
}

$2 == "QUEUE" {
    QueueType=$1
    sub(/^[ \t]+/, "", QueueType)
    sub(/[ \t]+$/, "", QueueType)
    ReplicationGroup=""
    ScheduleGroup=""
    next
}
$2 == "NOTES" {
    sub(/.done|.cfg|.error/, "", $1)
    sub(/^p/, "", $1)
    sub(/^[ \t]+/, "", $1)
    sub(/[ \t]+$/, "", $1)
    ReplicationGroup = $1
    sub(/^[ \t]+/, "", ReplicationGroup)
    sub(/[ \t]+$/, "", ReplicationGroup)
    ScheduleGroup = $3
    sub(/^[ \t]+/, "", ScheduleGroup)
    sub(/[ \t]+$/, "", ScheduleGroup)
    RepGroup[ReplicationGroup,"queue"]=QueueType
    RepGroup[ReplicationGroup,"schedgrp"]=ScheduleGroup
    if (!((ScheduleGroup) in ExistSchedGroup))
    {
	ExistSchedGroup[ScheduleGroup]=1
	MaxSortSchedIdx++
	SortPtrnSchedGroup[MaxSortSchedIdx] = CreateSortPattern( ScheduleGroup )
	SortDataSchedGroup[MaxSortSchedIdx] = ScheduleGroup
    }
    if (!((ScheduleGroup,ReplicationGroup) in ExistRepGroup))
    {
	ExistRepGroup[ScheduleGroup,ReplicationGroup]=1
	MaxSortRepIdx++
	SortPtrnRepGroup[MaxSortRepIdx] = CreateSortPattern( ScheduleGroup )
	SortDataRepGroup[MaxSortRepIdx] = ScheduleGroup SUBSEP ReplicationGroup
    }
    DiskIdx=0
    next
}

$2 == "REMARK" {
    sub(/.done|.cfg|.error/,"",$1)
    sub(/^p/,"",$1)
    sub(/^[ \t]+/, "", $1)
    sub(/[ \t]+$/, "", $1)
    source_info = $3
    sub(/^[ \t]+/, "", source_info)
    sub(/[ \t]+$/, "", source_info)
    target_info = $4
    sub(/^[ \t]+/, "", target_info)
    sub(/[ \t]+$/, "", target_info)
    if (NF >= 6 && $5 == "SIZEMB")
	source_size_mb = $6
    else
	source_size_mb = 0
    DiskIdx++
    RepDevice[ReplicationGroup,DiskIdx,"SourceLun"] = source_info
    RepDevice[ReplicationGroup,DiskIdx,"TargetLun"] = target_info
    RepDevice[ReplicationGroup,DiskIdx,"SizeMB"] = source_size_mb
    RepGroup[ReplicationGroup,"MaxDiskIdx"] = DiskIdx
    next
}

$2 == "DTC-DEVICE" {
    sub(/.done|.cfg|.error/,"",$1)
    sub(/^p/,"",$1)
    sub(/^[ \t]+/, "", $1)
    sub(/[ \t]+$/, "", $1)
    mig_device = $3
    sub(/^[ \t]+/, "", mig_device)
    sub(/[ \t]+$/, "", mig_device)
    RepDevice[ReplicationGroup,DiskIdx,"MigDevice"] = mig_device
    RepDevice[ReplicationGroup,DiskIdx,"NetActual"] = 0
    RepDevice[ReplicationGroup,DiskIdx,"NetEffective"] = 0
    RepDevice[ReplicationGroup,DiskIdx,"PercentDone"] = 0
    RepDevice[ReplicationGroup,DiskIdx,"State"] = OMP_STATE_UNKNOWN
    if (QueueType ~ /Wait|Active/)
    {
	RepDevice[ReplicationGroup,DiskIdx,"State"] = OMP_STATE_STARTED
    }
    if (QueueType == "Done")
    {
	RepDevice[ReplicationGroup,DiskIdx,"State"] = OMP_STATE_DONE
	RepDevice[ReplicationGroup,DiskIdx,"PercentDone"] = 100
    }
    if (QueueType == "Error")
    {
	RepDevice[ReplicationGroup,DiskIdx,"State"] = OMP_STATE_ERROR
    }

    RepDeviceMap[mig_device,"DiskIdx"] = DiskIdx
    RepDeviceMap[mig_device,"RepGroup"] = ReplicationGroup
    next
}

$2 == "PERFORMANCE" {
    if (NF < 6)
    {
	next
    }
    sub(/.prf/,"",$1)
    sub(/^p/,"",$1)
    sub(/^[ \t]+/, "", $1)
    sub(/[ \t]+$/, "", $1)
    sub(/^[ \t]+/, "", $3)
    sub(/[ \t]+$/, "", $3)
    sub(/^[ \t]+/, "", $4)
    sub(/[ \t]+$/, "", $4)
    sub(/^[ \t]+/, "", $5)
    sub(/[ \t]+$/, "", $5)

    RepGroup[ReplicationGroup,"Timestamp"]=$3 ":" $4 ":" $5

    for (I=6; I <= NF; I++)
    {
	N=split($I,perfdata," ")
	mig_device=perfdata[1]
	Idx = RepDeviceMap[mig_device,"DiskIdx"]
	RepDevice[ReplicationGroup,Idx,"NetActual"] = perfdata[2]
	RepDevice[ReplicationGroup,Idx,"NetEffective"] = perfdata[3]
	RepDevice[ReplicationGroup,Idx,"PercentDone"] = perfdata[6]
	RepDevice[ReplicationGroup,Idx,"State"] = set_state( OMP_STATE_UNKNOWN, perfdata[8])
	if (perfdata[8]  == REP_STATE_NORMAL)
	{
	    RepDevice[ReplicationGroup,Idx,"PercentDone"] = 100
	}
    }
    next
}
{ print "EXTRA |" $0 "|" }

END {
    CalculateStatistics()
    HeapSort( "SchedGroup", MaxSortSchedIdx );
    HeapSort( "RepGroup", MaxSortRepIdx );
    PrintStatistics()
}
