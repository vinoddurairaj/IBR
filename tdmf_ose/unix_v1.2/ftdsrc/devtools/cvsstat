#!/usr/bin/ksh

Cmd=${0##*/}

# FindProgram [-t | -p | executable]...
#
# Verify that the executables listed can be found within the PATH variable
#
# -t will not print an error message for the remaining executables
# -p will print an error message for the remaining executables (default)
#
# Returns failure if any executable is not found

function FindProgram
{
    typeset prog path
    typeset -u PROG
    typeset -i printMsg=1
    typeset -i status=0

    for prog
    do
	[[ "${prog}" = '-t' ]] && { let printMsg=0; continue; }
	[[ "${prog}" = '-p' ]] && { let printMsg=1; continue; }
	if path=$(whence -p ${prog})
	then
	    PROG="${prog}"
	    eval alias -x ${PROG}=\"${path}\"
	else
	    [[ "${printMsg}" -ne 0 ]] && print "${Cmd}: Could not find program ${prog}"
	    let status=1
	fi
    done
    return ${status} 
}

# Aliases are processed at read time, execution time.  We need to setup
# aliases as soon as possible.  Functions above this point cannot use
# aliases.  Only the shell builtin commands should be used until this point.

FindProgram cat rm cvs printf more basename || exit $?

if FindProgram -t nawk
then
    alias AWK=NAWK
else
    FindProgram awk || exit $?
fi

function UsageDescription
{
    typeset use="Usage: $Cmd "
    typeset len=${#use}

    print "${use}[ (dir)depth=number ] [ ignore=notinrepository ]"
    PRINTF "%${len}s%s\n" "" "[ (stop)at=directtory | (stop)before=directory"
    PRINTF "%${len}s%s\n" "" "| (stop)after=directory ] [ -? | -h(elp) ]" 
    PRINTF "%${len}s%s\n\n" "" "[ files | directories ]..." 
    print "\tThe cvsstat command finds the list of files that are not up to"
    print "\tdate on a single line.  This command prints the reason why the"
    print "\tfile is not update to date, repository pathname, the working"
    print "\tdirectory revision information and respository revision"
    print "\tinformation on a tsingle line.\n"

    print "\tCvsstat options defaults to stopat=ftdsrc and dirdepth=3 when no"
    print "\tcvsstat options are given.  If any cvsstat options are given then"
    print "\tthe default parameters are not used.\n"

    print "\tThe dirdepth is the number of directories to display back from the"
    print "\tfilename.  A directory depth of zero means the complete"
    print "\trepository pathname string is displayed.\n"

    print "\tThe stop options name the directory name it should find and stop"
    print "\tdisplaying the pathname at.  The stop commands will stop at,"
    print "\tbefore, or after the named directory based upon the stop option"
    print "\tbeing used.\n"

    print "\tThe ignore option names the reason to be skipped over.  Currently"
    print "\tonly the not in repository reason is supported."
}

function Usage
{
    typeset moreArg="-e"
    typeset -ru OsType=$(uname -s)

    [[ "${OsType}" = "LINUX" ]] && moreArg=
    UsageDescription | MORE ${moreArg}
}

function DefaultParameters
{
    export STOPAT=ftdsrc
    export STOPDEPTH=3
    return 0
}

function ProcessStopDirectory
{
    typeset -u parm=$1
    typeset arg=$2

    if [[ -z "${STOPAT}${STOPBEFORE}${STOPAFER}" ]]
    then
	if [[ "${arg}" = "." ]]
	then
		arg=$(BASENAME $PWD)
	fi
	if [[ -n "${arg}" ]]
	then
	    eval export ${parm}=\"${arg}\"
	else
	    print "$Cmd: The $1 option must have a value.\n"
	    Usage
	    exit 1
	fi
    else
	print "$Cmd: Specify only one of the stop directory options.\n"
	Usage
	exit 1
    fi
}

function ParseParameters
{
    typeset -u key
    typeset parm
    typeset value
    typeset -i shiftAmount=0

    for parm
    do
	key=${parm}
	value=${parm#*=}
	case $key in 
	    ?(-|--|/)?(DIR|STOP)DEPTH=*)
		if [[ "${value}" = +([0-9]) ]]
		then
		    export STOPDEPTH="${value}"
		else
		    print "$Cmd: Specify zero or positive value for the depth option.\n"
		    Usage
		    exit 1
		fi
		;;
	    ?(-|--|/)?(STOP)AT=*)
		ProcessStopDirectory stopat "${value}"
		;;
	    ?(-|--|/)?(STOP)AFTER=*)
		ProcessStopDirectory stopafter "${value}"
		;;
	    ?(-|--|/)?(STOP)BEFORE=*)
		ProcessStopDirectory stopbefore "${value}"
		;;
	    @(-|--|/)@(\?|H|HE|HEL|HELP))
		Usage
		exit 0
		;;
	    ?(-|--|/)IGNORE=*)
		if [[ "${value}" = @(notinrepository) ]]
		then
		    export IGNORE="${value}"
		else
		    print "$Cmd: Specify notinrepository for the ignore option.\n"
		    Usage
		    exit 1
		fi
		;;
	    *=*)
		print "$Cmd: An invalid parameter has been specified.\n"
		Usage
		exit 1
		;;
	    *)
		break
		;;
	esac
	let shiftAmount+=1
    done
    return $shiftAmount
}

# 
# ParseParameters returns the number of parameters processed 
# so they can be shifted off.  When the return value is zero
# we then execute the setup for the default parameters.
#

ParseParameters "$@" && DefaultParameters
shift $?

AWKFILE="/tmp/$Cmd.$$"
CVSMSGS="/tmp/$Cmd.msgs.$$"
CVSERRS="/tmp/$Cmd.errs.$$"
trap "RM -f $AWKFILE $CVSMSGS $CVSERRS" 0 1 2 3 15

CAT <<ENDOFDATA >$AWKFILE
# Argument pathstring; Locals start, i, n, pathparts
function ParsePath(pathstring, start, i, n, pathparts)
{
    if (substr(pathstring, 1, 1) == "/")
    {
	pathstring = substr( pathstring, 2)
    }
    n=split(pathstring, pathparts ,/\//)
    if (!sub(/,v\$/, "", pathparts[n]))
    {
	print "Something wrong with pathname splitting processing"
    }
    if (filename != pathparts[n])
    {
	print "Something wrong with pathname matching"
    }

    start = 1;
    pathname=""
    for (i = n - 1; i >= 1; i--)
    {
	if (stopat != "" && stopat == pathparts[i])
	{
	    start=i;
	    break;
	}
	else if (stopafter != "" && stopafter == pathparts[i])
	{
	   start = i + 1
	   break;
	}
	else if (stopdepth != 0 && stopdepth == n - i)
	{
	    start=i;
	    pathname=".../"
	    break;
	}
	else if (i > 1 && stopbefore != "" && stopbefore == pathparts[i])
	{
	   start = i - 1
	   if (i <= 0) { start = 1 }
	   break;
	}
    }
    for(i=start; i < n; i++)
    {
	pathname= pathname pathparts[i] "/"
    }
    pathname= pathname pathparts[n]
    return pathname
}

BEGIN {
    Spaces="                                                            "
    if ("STOPDEPTH" in ENVIRON)
    {
	stopdepth=ENVIRON["STOPDEPTH"]
    }
    else
    {
	stopdepth=0
    }
    if (stopdepth < 0 || stopdepth !~ /^[0-9]+\$/)
    {
	print "Stop depth must be numeric and a positive number"
	exit 1
    }
    if ("STOPAT" in ENVIRON)
    {
	stopat=ENVIRON["STOPAT"]
	stopcnt++
    }
    if ("STOPAFTER" in ENVIRON)
    {
	stopafter=ENVIRON["STOPAFTER"]
	stopcnt++
    }
    if ("STOPBEFORE" in ENVIRON)
    {
	stopbefore=ENVIRON["STOPBEFORE"]
	stopcnt++
    }
    if (stopcnt > 1)
    {
	print "Only one stop type is allowed"
	exit 1
    }
    if ("IGNORE" in ENVIRON)
    {
	ignorelist=ENVIRON["IGNORE"]
	ignorelist=toupper(ignorelist)
    }
}

/^\?/ {
    if (ignorelist !~ /NOTINREPOSITORY/)
    {
	print "Not In Repository ", \$2
    }
}
/^File:/ {
    filename=\$2
    start=4
    if (\$2 == "no" && \$3 == "file" && \$5 == "Status:")
    {
	filename=\$4
	start=6
    }
    else if (\$3 != "Status:")
    {
	print "Warning: Somthing is not understood on the File line"
	print \$0
    }
    if (\$start != "Up-to-date")
    {
	Reason=\$start
	for (i=start+1; i<=NF; i++)
	{
	    Reason=Reason " " \$i
	}
	look=1
    }
    next
}

look == 1 && /^   Working revision:/ {
    if (\$3 == "New" && \$4 == "file!")
    {
	WorkingRevision=\$3 " " \$4 
    }
    else if (\$3 == "No" && \$4 == "entry" && \$5 == "for")
    {
	WorkingRevision=\$3 " " \$4
    }
    else
    {
	WorkingRevision=\$3
    }
    next
}
look == 1 && /^   Repository revision:/ {
    if (\$3 == "No" && \$4 == "revision" && \$5 == "control")
    {
	pathname=filename
	repositoryRevision=""
    }
    else
    {
	if (substr(\$4, 1, 1) == "/")
	{
	    \$4 = substr( \$4, 2)
	}
	pathname=ParsePath(\$4)
	repositoryRevision=\$3
    }
    line=Reason
    len=length(line)
    if (len <= 17)
    {
	line=line substr(Spaces, 1, (17-len))
    }
    line=line substr(Spaces, 1, 2) pathname
    revision=""
    if (WorkingRevision != "")
    {
	revision= "  " WorkingRevision
    }
    if (repositoryRevision != "")
    {
	revision= revision "  " repositoryRevision
    }
    len = length(line)
    rlen = length(revision)
    if (rlen > 0)
    {
	if (len + rlen < 79)
	{
	    line = line substr( Spaces, 1, 79 - len - rlen );
	}
	line = line revision
    }
    print line
    
    look=0
    next
}
ENDOFDATA
if [[ $? -ne 0  ]]
then
    print "${Cmd}: Cannot create temporary file $AWKFILE"
    exit 1
fi
CVS status "$@" 2>$CVSERRS 1>$CVSMSGS
if [[ "$?" -ne 0 ]]
then
    cat $CVSERRS
    exit 1
fi
AWK -f $AWKFILE $CVSMSGS
